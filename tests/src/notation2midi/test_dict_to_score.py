import unittest
from unittest.mock import MagicMock

from src.common.classes import Beat, Flow, Gongan, Measure, Notation, Note, Score
from src.common.constants import (
    DEFAULT,
    DynamicLevel,
    InstrumentType,
    ParserTag,
    Pitch,
    Position,
    RuleValue,
    Stroke,
)
from src.notation2midi.classes import MetaDataRecord
from src.notation2midi.dict_to_score import ScoreCreatorAgent
from src.notation2midi.metadata_classes import (
    DynamicsMeta,
    GonganMeta,
    GonganType,
    GoToMeta,
    KempliMeta,
    LabelMeta,
    MetaData,
    MetaDataBaseModel,
    MetaDataSwitch,
    OctavateMeta,
    SuppressMeta,
    TempoMeta,
    WaitMeta,
)
from src.settings.settings import Settings
from tests.conftest import BaseUnitTestCase

# pylint: disable=missing-module-docstring
# pylint: disable=missing-function-docstring
# pylint: disable=protected-access
# pylint: disable=invalid-name


class PositionNote:
    """Utility class to enable a compact notation of Note objects."""

    def __init__(self, position: Position, autogenerated=False):
        self.position = position
        self.autogenerated = autogenerated

    def note(self, **kwargs) -> Note:
        kwargs = {"octave": 1, "stroke": Stroke.OPEN, "duration": 1, "rest_after": 0} | kwargs
        new_note = Note.get_note(position=self.position, **kwargs)
        transformation = RuleValue.SAME_TONE if new_note.is_melodic() else None
        return new_note.model_copy(update={"autogenerated": self.autogenerated, "transformation": transformation})

    @property
    def DING(
        self,
    ):
        return self.note(pitch=Pitch.DING)

    @property
    def DONG(self):
        return self.note(pitch=Pitch.DONG)

    @property
    def DONGMUTED(self):
        return self.note(pitch=Pitch.DONG, stroke=Stroke.MUTED)

    @property
    def DENG(self):
        return self.note(pitch=Pitch.DENG)

    @property
    def DUNG(self):
        return self.note(pitch=Pitch.DUNG)

    @property
    def DANG(self):
        return self.note(pitch=Pitch.DANG)

    @property
    def MUTEDSTRIKE(self):
        return self.note(pitch=Pitch.STRIKE, octave=None, stroke=Stroke.MUTED)

    @property
    def SILENCE(self):
        return self.note(pitch=Pitch.NONE, octave=None, stroke=Stroke.SILENCE, duration=0, rest_after=1)

    @property
    def EXTENSION(self):
        return self.note(pitch=Pitch.NONE, octave=None, stroke=Stroke.EXTENSION)


P = PositionNote(Position.PEMADE_POLOS)
Pa = PositionNote(Position.PEMADE_POLOS, autogenerated=True)
S = PositionNote(Position.PEMADE_SANGSIH)
Sa = PositionNote(Position.PEMADE_SANGSIH, autogenerated=True)
J = PositionNote(Position.JEGOGAN)
Ja = PositionNote(Position.JEGOGAN, autogenerated=True)
C = PositionNote(Position.CALUNG)
Ca = PositionNote(Position.CALUNG, autogenerated=True)
Ka = PositionNote(Position.KEMPLI, autogenerated=True)


def create_beat(beat_id: int = 1, content: dict[PositionNote, list[Note]] = None):
    measures = {
        pn.position: Measure(
            position=pn.position,
            all_positions=pn.position,
            passes={DEFAULT: Measure.Pass(seq=-1, notes=[note for note in measure])},
        )
        for pn, measure in content.items()
    }
    return Beat(
        id=beat_id,
        gongan_id=1,
        flow=Flow(bpm_start={-1: 60}, bpm_end={-1: 60}, velocities_start={}, velocities_end={}),
        duration=4,
        measures=measures,
    )


def get_notation():
    p = PositionNote(Position.PEMADE_POLOS)
    notation = {
        -1: {ParserTag.METADATA: [], ParserTag.COMMENTS: [], ParserTag.BEATS: {}},
        1: {
            ParserTag.METADATA: [MetaDataRecord(metatype="KEMPLI", status=MetaDataSwitch.OFF, line=1)],
            ParserTag.COMMENTS: ["Gongan 1"],
            ParserTag.BEATS: {
                1: {
                    (Position.PEMADE_POLOS): Measure(
                        position=Position.PEMADE_POLOS,
                        all_positions=Position.PEMADE_POLOS,
                        passes={-1: Measure.Pass(seq=-1, line=3, notes=[p.DING, p.DUNG, p.DENG, p.DANG])},
                    ),
                },
            },
        },
        2: {
            ParserTag.METADATA: [],
            ParserTag.COMMENTS: ["Gongan 2"],
            ParserTag.BEATS: {
                1: {
                    (Position.PEMADE_POLOS): Measure(
                        position=Position.PEMADE_POLOS,
                        all_positions=Position.PEMADE_POLOS,
                        passes={-1: Measure.Pass(seq=-1, line=3, notes=[p.DING, p.DONG, p.DENG, p.DUNG])},
                    ),
                },
            },
        },
    }
    return notation


class TestDictToScoreConverter(BaseUnitTestCase):

    def setUp(self):
        pass

    def get_converter_gk(self):
        settings = Settings.get(notation_id="test-gongkebyar", part_id="full")
        mock_notation = MagicMock(spec=Notation)
        mock_notation.settings = settings
        mock_notation.notation_dict = get_notation()
        return ScoreCreatorAgent(settings, mock_notation)

    def get_converter_beat_at_end(self):
        settings = Settings.get(notation_id="test_beat_at_end", part_id="full")
        mock_notation = MagicMock(spec=Notation)
        mock_notation.settings = settings
        mock_notation.notation_dict = get_notation()
        return ScoreCreatorAgent(settings, mock_notation)

    def test_create_score(self):
        converter = self.get_converter_gk()
        score = converter.run()
        self.assertIsInstance(score, Score)
        self.assertEqual(
            converter.score.gongans[0].beats[0].measures[Position.PEMADE_POLOS],
            converter.notation.notation_dict[1][ParserTag.BEATS][1][Position.PEMADE_POLOS],
        )

    def test_get_all_positions(self):
        notation_dict = {
            1: {ParserTag.BEATS: {1: {Position.UGAL: [], Position.CALUNG: []}}},
            2: {ParserTag.BEATS: {1: {Position.JEGOGAN: [], Position.GONGS: []}}},
        }
        converter = self.get_converter_gk()
        positions = converter._get_all_positions(notation_dict)
        expected_positions = {Position.UGAL, Position.CALUNG, Position.JEGOGAN, Position.GONGS}
        self.assertEqual(positions, expected_positions)

    def test_has_kempli_beat(self):
        converter = self.get_converter_gk()
        score = converter.run()
        self.assertFalse(converter._has_kempli_beat(score.gongans[0]))
        self.assertTrue(converter._has_kempli_beat(score.gongans[1]))

    def test_move_beat_to_start1(self):
        # Test that the method is only called if beat_at_end is set.
        for getter in [self.get_converter_gk, self.get_converter_beat_at_end]:
            converter = getter()
            converter._move_beat_to_start = MagicMock(return_value=None)
            converter.run()
            if getter == self.get_converter_beat_at_end:
                converter._move_beat_to_start.assert_called_once()
            else:
                converter._move_beat_to_start.assert_not_called()

    def test_move_beat_to_start2(self):
        # Original score:
        #   gongan1: iuea
        #   gongan2: ioeu
        converter = self.get_converter_beat_at_end()
        converter.run()
        # Assert that the content of the first gongan was shifted by one note and that a silence
        # was added at the beginning.
        self.assertEqual(
            converter.score.gongans[0].beats[0].measures[Position.PEMADE_POLOS].passes[-1].notes,
            [P.SILENCE, P.DING, P.DUNG, P.DENG],
        )
        # Assert that the content of the second gongan was shifted by one note
        # and that its first beat now contains the last note of the previous beat.
        self.assertEqual(
            converter.score.gongans[1].beats[0].measures[Position.PEMADE_POLOS].passes[-1].notes,
            [P.DANG, P.DING, P.DONG, P.DENG],
        )
        # Assert that the second gongan has a kempli beat, and that the status is 'autogenerated'
        self.assertTrue(Position.KEMPLI in converter.score.gongans[1].beats[0].measures.keys())
        self.assertEqual(
            converter.score.gongans[1].beats[0].measures[Position.KEMPLI].passes[-1].notes,
            [Ka.MUTEDSTRIKE, Ka.EXTENSION, Ka.EXTENSION, Ka.EXTENSION],
        )
        # Assert that a new gongan was created containing the last note of the previous
        # gongan and a kempli beat.
        self.assertEqual(len(converter.score.gongans), 3)
        self.assertEqual(converter.score.gongans[2].beats[0].measures[Position.PEMADE_POLOS].passes[-1].notes, [P.DUNG])
        self.assertTrue(Position.KEMPLI in converter.score.gongans[2].beats[0].measures.keys())
        self.assertEqual(
            converter.score.gongans[2].beats[0].measures[Position.KEMPLI].passes[-1].notes,
            [Ka.MUTEDSTRIKE],
        )

    def test_create_rest_measure(self):
        converter = self.get_converter_beat_at_end()
        rest_measure = converter._create_rest_measure(Position.PEMADE_POLOS, Stroke.SILENCE, 2.5)
        self.assertEqual(len(rest_measure.passes[DEFAULT].notes), 3)
        self.assertEqual(rest_measure.passes[DEFAULT].notes[0].total_duration, 1)
        self.assertEqual(rest_measure.passes[DEFAULT].notes[1].total_duration, 1)
        self.assertEqual(rest_measure.passes[DEFAULT].notes[2].total_duration, 0.5)

    def test_create_rest_measures(self):

        converter = self.get_converter_gk()
        prev_beat = create_beat(
            1,
            {
                P: [P.DING, P.DONG, P.EXTENSION, P.EXTENSION],
                S: [S.DING, S.DONG, S.DONG, S.DONG],
                J: [J.DING, J.DONG, J.DING, J.SILENCE],
                C: [C.DING, C.DONG, C.DING, C.DONG],
            },
        )
        result = converter._create_rest_measures(
            prev_beat,
            positions=[
                Position.PEMADE_POLOS,
                Position.PEMADE_SANGSIH,
                Position.JEGOGAN,
                Position.CALUNG,
            ],
            duration=4,
            force_silence=[Position.CALUNG],
            pass_seq=DEFAULT,
        )
        self.assertEqual(
            result[Position.PEMADE_POLOS].passes[DEFAULT].notes,
            [Pa.EXTENSION, Pa.EXTENSION, Pa.EXTENSION, Pa.EXTENSION],
        )
        self.assertEqual(
            result[Position.PEMADE_SANGSIH].passes[DEFAULT].notes,
            [Sa.EXTENSION, Sa.EXTENSION, Sa.EXTENSION, Sa.EXTENSION],
        )
        self.assertEqual(
            result[Position.JEGOGAN].passes[DEFAULT].notes, [Ja.SILENCE, Ja.SILENCE, Ja.SILENCE, Ja.SILENCE]
        )
        self.assertEqual(
            result[Position.CALUNG].passes[DEFAULT].notes, [Ca.SILENCE, Ca.SILENCE, Ca.SILENCE, Ca.SILENCE]
        )

    def create_gongan_with_metadata(self, gongan_id: int, meta_list: list[MetaDataBaseModel]):
        beats = [
            create_beat(
                1,
                {
                    P: [P.DONG, P.SILENCE, P.DENG, P.DONG],
                    S: [S.DUNG, S.DANG, S.SILENCE, S.DUNG],
                    J: [J.DING, J.EXTENSION, J.EXTENSION, J.EXTENSION],
                    C: [C.DING, C.EXTENSION, C.DONG, C.EXTENSION],
                },
            ),
            create_beat(
                2,
                {
                    P: [P.SILENCE, P.DONG, P.DENG, P.SILENCE],
                    S: [S.DENG, S.DUNG, S.SILENCE, S.DENG],
                    J: [J.DING, J.EXTENSION, J.EXTENSION, J.EXTENSION],
                    C: [C.DING, C.EXTENSION, C.DONG, C.EXTENSION],
                },
            ),
        ]
        return Gongan(id=gongan_id, beats=beats, metadata=meta_list)

    def test_apply_meta(self):
        # Test for _apply_metadata method
        Settings.get(notation_id="test-gongkebyar", part_id="full")  # Needed to initialize classes
        converter = self.get_converter_gk()
        gongan: Gongan = None
        # pylint: disable=unnecessary-lambda-assignment
        # lambda is used to delay the calculation of the value to be tested
        tests = [
            (
                gongan := self.create_gongan_with_metadata(
                    1,
                    [
                        DynamicsMeta(
                            abbreviation=DynamicLevel.PIANISSIMO,
                            first_beat=1,
                            positions=[Position.PEMADE_POLOS, Position.PEMADE_SANGSIH],
                        )
                    ],
                ),
                value := lambda: gongan.beats[0].changes,
                expected := {
                    Flow.Change.Type.DYNAMICS: {
                        -1: Flow.Change(
                            new_value=gongan.metadata[0].value,
                            positions=[Position.PEMADE_POLOS, Position.PEMADE_SANGSIH],
                            incremental=False,
                        )
                    }
                },
            ),
            (
                gongan := self.create_gongan_with_metadata(2, [GonganMeta(type=GonganType.KEBYAR)]),
                value := lambda: (gongan.gongantype, all(not beat.has_kempli_beat for beat in gongan.beats)),
                expected := (GonganType.KEBYAR, True),
            ),
            (
                gongan := self.create_gongan_with_metadata(3, [GonganMeta(type=GonganType.REGULAR)]),
                value := lambda: (gongan.gongantype, all(beat.has_kempli_beat for beat in gongan.beats)),
                expected := (GonganType.REGULAR, True),
            ),
            # add GotoMeta
            (
                gongan := self.create_gongan_with_metadata(4, [KempliMeta(status=MetaDataSwitch.OFF)]),
                value := lambda: (gongan.gongantype, all(not beat.has_kempli_beat for beat in gongan.beats)),
                expected := (GonganType.REGULAR, True),
            ),
            # add LabelMeta
            (
                gongan := self.create_gongan_with_metadata(
                    5, [OctavateMeta(instrument=InstrumentType.PEMADE, octaves=-1)]
                ),
                value := lambda: gongan.beats[0].measures[P.position].passes[DEFAULT].notes,
                expected := [
                    P.DONG.model_copy_x(octave=0, transformation=RuleValue.SAME_PITCH),
                    P.SILENCE,
                    P.DENG.model_copy_x(octave=0, transformation=RuleValue.SAME_PITCH),
                    P.DONG.model_copy_x(octave=0, transformation=RuleValue.SAME_PITCH),
                ],
            ),
            #     add RepeatMeta
            #     add SequenceMeta
            #     add SuppressMeta
            #     add TempoMeta
            #     add ValidationMeta
            #     add WaitMeta
        ]
        # pylint: enable=unnecessary-lambda-assignment
        for gongan, value, expected in tests:
            with self.subTest(gongan_id=gongan.id):
                converter._apply_metadata(gongan)
                self.assertEqual(value(), expected)

    def test_add_missing_measures(self):
        # Add test for _add_missing_measure method
        pass

    def test_extend_measure(self):
        # Add test for _extend_measure method
        pass

    def test_complement_shorthand_pokok_measure(self):
        # Add test for _complement_shorthand_pokok_measure method
        pass

    def test_process_goto(self):
        # Add test for _process_goto method
        pass

    def test_process_sequences(self):
        pass

    def test_create_missing_measures(self):
        pass

    def test_init(self):
        # Test initialization with a mock Notation object
        pass
        # self.assertEqual(self.converter.notation, self.mock_notation)
        # self.assertEqual(
        #     self.converter.DEFAULT_VELOCITY, self.settings.midi.dynamics[self.settings.midi.default_dynamics]
        # )
        # self.assertEqual(self.converter.score.title, self.settings.notation.title)
        # self.assertEqual(self.converter.score.settings, self.mock_notation.settings)
        # self.assertEqual(
        #     self.converter.score.instrument_positions,
        #     self.converter._get_all_positions(self.mock_notation.notation_dict),
        # )


if __name__ == "__main__":
    unittest.main()
