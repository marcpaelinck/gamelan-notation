import unittest
from unittest.mock import MagicMock

from src.common.classes import Beat, Gongan, Measure, Note
from src.common.constants import (
    DEFAULT,
    DynamicLevel,
    Pitch,
    Position,
    RuleValue,
    Stroke,
)
from src.notation2midi.execution import Dynamics, Score
from src.notation2midi.metadata_classes import DynamicsMeta, MetaDataBaseModel
from src.notation2midi.pipeline.create_execution import ExecutionCreatorAgent
from src.settings.settings import Settings
from tests.conftest import BaseUnitTestCase

# pylint: disable=missing-module-docstring
# pylint: disable=missing-function-docstring
# pylint: disable=protected-access
# pylint: disable=invalid-name


class PositionNote:
    """Utility class to enable a compact notation of Note objects."""

    def __init__(self, position: Position, autogenerated=False):
        self.position = position
        self.autogenerated = autogenerated

    def note(self, **kwargs) -> Note:
        kwargs = {"octave": 1, "stroke": Stroke.OPEN, "duration": 1, "rest_after": 0} | kwargs
        new_note = Note.get_note(position=self.position, **kwargs)
        transformation = RuleValue.SAME_TONE if new_note.is_melodic() else None
        return new_note.model_copy(update={"autogenerated": self.autogenerated, "transformation": transformation})

    @property
    def DING(
        self,
    ):
        return self.note(pitch=Pitch.DING)

    @property
    def DONG(self):
        return self.note(pitch=Pitch.DONG)

    @property
    def DONGMUTED(self):
        return self.note(pitch=Pitch.DONG, stroke=Stroke.MUTED)

    @property
    def DENG(self):
        return self.note(pitch=Pitch.DENG)

    @property
    def DUNG(self):
        return self.note(pitch=Pitch.DUNG)

    @property
    def DANG(self):
        return self.note(pitch=Pitch.DANG)

    @property
    def MUTEDSTRIKE(self):
        return self.note(pitch=Pitch.STRIKE, octave=None, stroke=Stroke.MUTED)

    @property
    def SILENCE(self):
        return self.note(pitch=Pitch.NONE, octave=None, stroke=Stroke.SILENCE, duration=0, rest_after=1)

    @property
    def EXTENSION(self):
        return self.note(pitch=Pitch.NONE, octave=None, stroke=Stroke.EXTENSION)


P = PositionNote(Position.PEMADE_POLOS)
Pa = PositionNote(Position.PEMADE_POLOS, autogenerated=True)
S = PositionNote(Position.PEMADE_SANGSIH)
Sa = PositionNote(Position.PEMADE_SANGSIH, autogenerated=True)
J = PositionNote(Position.JEGOGAN)
Ja = PositionNote(Position.JEGOGAN, autogenerated=True)
C = PositionNote(Position.CALUNG)
Ca = PositionNote(Position.CALUNG, autogenerated=True)
Ka = PositionNote(Position.KEMPLI, autogenerated=True)


def create_beat(beat_id: int = 1, content: dict[PositionNote, list[Note]] = None):
    measures = {
        pn.position: Measure(
            position=pn.position,
            all_positions=pn.position,
            passes={DEFAULT: Measure.Pass(seq=-1, notes=[note for note in measure])},
        )
        for pn, measure in content.items()
    }
    return Beat(
        id=beat_id,
        gongan_id=1,
        duration=4,
        measures=measures,
    )


class TestDictToScoreConverter(BaseUnitTestCase):

    def setUp(self):
        pass

    def get_converter_gk(self):
        settings = Settings.get(notation_id="test-gongkebyar", part_id="full")
        mock_score = MagicMock(spec=Score)
        mock_score.settings = settings
        mock_score.gongans = {}
        mock_score.global_metadata = []
        return ExecutionCreatorAgent(mock_score)

    def create_gongan_with_metadata(self, gongan_id: int, meta_list: list[MetaDataBaseModel]):
        beats = [
            create_beat(
                1,
                {
                    P: [P.DONG, P.SILENCE, P.DENG, P.DONG],
                    S: [S.DUNG, S.DANG, S.SILENCE, S.DUNG],
                    J: [J.DING, J.EXTENSION, J.EXTENSION, J.EXTENSION],
                    C: [C.DING, C.EXTENSION, C.DONG, C.EXTENSION],
                },
            ),
            create_beat(
                2,
                {
                    P: [P.SILENCE, P.DONG, P.DENG, P.SILENCE],
                    S: [S.DENG, S.DUNG, S.SILENCE, S.DENG],
                    J: [J.DING, J.EXTENSION, J.EXTENSION, J.EXTENSION],
                    C: [C.DING, C.EXTENSION, C.DONG, C.EXTENSION],
                },
            ),
        ]
        return Gongan(id=gongan_id, beats=beats, metadata=meta_list)

    def test_apply_meta(self):
        # Test for _apply_metadata method
        Settings.get(notation_id="test-gongkebyar", part_id="full")  # Needed to initialize classes
        converter = self.get_converter_gk()
        gongan: Gongan = None
        # pylint: disable=unnecessary-lambda-assignment
        # lambda is used to delay the calculation of the value to be tested
        tests = [
            (
                gongan := self.create_gongan_with_metadata(
                    1,
                    [
                        DynamicsMeta(
                            abbreviation=DynamicLevel.PIANISSIMO,
                            first_beat=1,
                            positions=[Position.PEMADE_POLOS, Position.PEMADE_SANGSIH],
                        )
                    ],
                ),
                value := lambda: converter.execution.dynamics(gongan.beats[0]),
                expected := Dynamics(
                    value_dict={
                        (pos, DEFAULT, DEFAULT): gongan.metadata[0].value for pos in gongan.metadata[0].positions
                    },
                    gradual=False,
                ),
            ),
            #     add LoopMeta
            #     add SequenceMeta
            #     add TempoMeta
        ]
        # pylint: enable=unnecessary-lambda-assignment
        for gongan, value, expected in tests:
            with self.subTest(gongan_id=gongan.id):
                converter._apply_metadata(gongan)
                self.assertEqual(value(), expected)

    def test_process_goto(self):
        # Add test for _process_goto method
        pass

    def test_process_sequences(self):
        pass


if __name__ == "__main__":
    unittest.main()
