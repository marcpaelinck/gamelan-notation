from unittest.mock import MagicMock

from src.common.classes import Beat, Gongan, Measure
from src.common.constants import (
    DEFAULT,
    GonganType,
    InstrumentType,
    Pitch,
    Position,
    RuleValue,
)
from src.common.notes import Note, NoteFactory
from src.notation2midi.execution.execution import Score
from src.notation2midi.metadata_classes import (
    GonganMeta,
    KempliMeta,
    MetaDataBaseModel,
    MetaDataSwitch,
    OctavateMeta,
)
from src.notation2midi.pipeline.score_postprocessing import ScorePostprocessAgent
from src.settings.classes import RunSettings
from src.settings.settings import Settings
from tests.conftest import BaseUnitTestCase
from tests.src.utils_for_tests import PositionNote


def create_beat(beat_id: int = 1, content: dict[PositionNote, list[Note]] = None):
    measures = {
        pn.position: Measure(
            position=pn.position,
            all_positions=pn.position,
            passes={DEFAULT: Measure.Pass(seq=-1, notes=[note for note in measure])},
        )
        for pn, measure in content.items()
    }
    return Beat(
        id=beat_id,
        gongan_id=1,
        measures=measures,
    )


P = PositionNote(Position.PEMADE_POLOS)
Pa = PositionNote(Position.PEMADE_POLOS, autogenerated=True)
K = PositionNote(Position.KANTILAN_POLOS)
Ka = PositionNote(Position.KANTILAN_POLOS, autogenerated=True)
S = PositionNote(Position.PEMADE_SANGSIH)
Sa = PositionNote(Position.PEMADE_SANGSIH, autogenerated=True)
J = PositionNote(Position.JEGOGAN)
Ja = PositionNote(Position.JEGOGAN, autogenerated=True)
C = PositionNote(Position.CALUNG)
Ca = PositionNote(Position.CALUNG, autogenerated=True)
Ka = PositionNote(Position.KEMPLI, autogenerated=True)


def get_score(run_settings: RunSettings):
    score = Score(
        title="test",
        settings=run_settings,
        instrument_positions={P.position, K.position},
        gongans=[
            Gongan(
                id=1,
                metadata=[KempliMeta(metatype="KEMPLI", status=MetaDataSwitch.OFF)],
                beats=[
                    beat1 := Beat(
                        id=1,
                        gongan_id=1,
                        measures={
                            P.position: Measure(
                                position=P.position,
                                all_positions=[P.position, K.position],
                                passes={-1: Measure.Pass(seq=-1, notes=[P.DING1, P.DUNG1, P.DENG1, P.DANG1])},
                            )
                        },
                    ),
                    beat2 := Beat(
                        id=2,
                        gongan_id=1,
                        measures={
                            P.position: Measure(
                                position=P.position,
                                all_positions=[P.position, K.position],
                                passes={-1: Measure.Pass(seq=-1, notes=[P.DING1, P.DONG1, P.DONG1MUTED, P.DING2])},
                            )
                        },
                    ),
                ],
            ),
            Gongan(
                id=2,
                metadata=[],
                beats=[
                    beat3 := Beat(
                        id=1,
                        gongan_id=2,
                        measures={
                            P.position: Measure(
                                position=P.position,
                                all_positions=[P.position, K.position],
                                passes={-1: Measure.Pass(seq=-1, notes=[P.DING1, P.DUNG0, P.DENG0, P.DANG0])},
                            )
                        },
                    ),
                ],
            ),
        ],
    )
    beat1.next = beat2
    beat2.next = beat3
    beat3.prev = beat2
    beat2.prev = beat1

    return score


class TestTScorePostprocessAgent(BaseUnitTestCase):

    def setUp(self):
        pass

    def get_converter_gk(self):
        run_settings = Settings.get(notation_id="test-gongkebyar", part_id="full")
        score = get_score(run_settings)
        return ScorePostprocessAgent(score)

    def get_converter_beat_at_end(self):
        run_settings = Settings.get(notation_id="test_beat_at_end", part_id="full")
        score = get_score(run_settings)
        return ScorePostprocessAgent(score)

    def test_has_kempli_beat(self):
        converter = self.get_converter_gk()
        score = converter.run()
        self.assertFalse(converter._has_kempli_beat(score.gongans[0]))
        self.assertTrue(converter._has_kempli_beat(score.gongans[1]))

    def test_create_rest_measure(self):
        converter = self.get_converter_beat_at_end()
        rest_measure = converter._create_rest_measure(Position.PEMADE_POLOS, Pitch.SILENCE, 2.5)
        self.assertEqual(len(rest_measure.passes[DEFAULT].notes), 3)
        self.assertEqual(rest_measure.passes[DEFAULT].notes[0].duration, 1)
        self.assertEqual(rest_measure.passes[DEFAULT].notes[1].duration, 1)
        self.assertEqual(rest_measure.passes[DEFAULT].notes[2].duration, 0.5)

    def test_create_rest_measures(self):

        converter = self.get_converter_gk()
        prev_beat = create_beat(
            1,
            {
                P: [P.DING1, P.DONG1, P.EXTENSION, P.EXTENSION],
                S: [S.DING1, S.DONG1, S.DONG1, S.DONG1],
                J: [J.DING1, J.DONG1, J.DING1, J.SILENCE],
                C: [C.DING1, C.DONG1, C.DING1, C.DONG1],
            },
        )
        result = converter._create_rest_measures(
            prev_beat,
            positions=[
                Position.PEMADE_POLOS,
                Position.PEMADE_SANGSIH,
                Position.JEGOGAN,
                Position.CALUNG,
            ],
            duration=4,
            force_silence=[Position.CALUNG],
            pass_seq=DEFAULT,
        )
        self.assertEqual(
            result[Position.PEMADE_POLOS].passes[DEFAULT].notes,
            [Pa.EXTENSION, Pa.EXTENSION, Pa.EXTENSION, Pa.EXTENSION],
        )
        self.assertEqual(
            result[Position.PEMADE_SANGSIH].passes[DEFAULT].notes,
            [Sa.EXTENSION, Sa.EXTENSION, Sa.EXTENSION, Sa.EXTENSION],
        )
        self.assertEqual(
            result[Position.JEGOGAN].passes[DEFAULT].notes, [Ja.SILENCE, Ja.SILENCE, Ja.SILENCE, Ja.SILENCE]
        )
        self.assertEqual(
            result[Position.CALUNG].passes[DEFAULT].notes, [Ca.SILENCE, Ca.SILENCE, Ca.SILENCE, Ca.SILENCE]
        )

    def create_gongan_with_metadata(self, gongan_id: int, meta_list: list[MetaDataBaseModel]):
        beats = [
            create_beat(
                1,
                {
                    P: [P.DONG1, P.SILENCE, P.DENG1, P.DONG1],
                    S: [S.DUNG1, S.DANG1, S.SILENCE, S.DUNG1],
                    J: [J.DING1, J.EXTENSION, J.EXTENSION, J.EXTENSION],
                    C: [C.DING1, C.EXTENSION, C.DONG1, C.EXTENSION],
                },
            ),
            create_beat(
                2,
                {
                    P: [P.SILENCE, P.DONG1, P.DENG1, P.SILENCE],
                    S: [S.DENG1, S.DUNG1, S.SILENCE, S.DENG1],
                    J: [J.DING1, J.EXTENSION, J.EXTENSION, J.EXTENSION],
                    C: [C.DING1, C.EXTENSION, C.DONG1, C.EXTENSION],
                },
            ),
        ]
        return Gongan(id=gongan_id, beats=beats, metadata=meta_list)

    def test_apply_meta(self):
        # Test for _apply_metadata method
        Settings.get(notation_id="test-gongkebyar", part_id="full")  # Needed to initialize classes
        converter = self.get_converter_gk()
        gongan: Gongan = None
        # pylint: disable=unnecessary-lambda-assignment
        # lambda is used to delay the calculation of the value to be tested
        tests = [
            (
                gongan := self.create_gongan_with_metadata(2, [GonganMeta(type=GonganType.KEBYAR)]),
                value := lambda: (gongan.gongantype, all(not beat.has_kempli_beat for beat in gongan.beats)),
                expected := (GonganType.KEBYAR, True),
            ),
            (
                gongan := self.create_gongan_with_metadata(3, [GonganMeta(type=GonganType.REGULAR)]),
                value := lambda: (gongan.gongantype, all(beat.has_kempli_beat for beat in gongan.beats)),
                expected := (GonganType.REGULAR, True),
            ),
            # add GotoMeta
            (
                gongan := self.create_gongan_with_metadata(4, [KempliMeta(status=MetaDataSwitch.OFF)]),
                value := lambda: (gongan.gongantype, all(not beat.has_kempli_beat for beat in gongan.beats)),
                expected := (GonganType.REGULAR, True),
            ),
            # add LabelMeta
            (
                gongan := self.create_gongan_with_metadata(
                    5, [OctavateMeta(instrument=InstrumentType.PEMADE, octaves=-1)]
                ),
                value := lambda: gongan.beats[0].measures[P.position].passes[DEFAULT].notes,
                expected := [
                    NoteFactory.clone_note(P.DONG1, octave=0, transformation=RuleValue.SAME_PITCH),
                    P.SILENCE,
                    NoteFactory.clone_note(P.DENG1, octave=0, transformation=RuleValue.SAME_PITCH),
                    NoteFactory.clone_note(P.DONG1, octave=0, transformation=RuleValue.SAME_PITCH),
                ],
            ),
            #     add SuppressMeta
            #     add ValidationMeta
            #     add WaitMeta
        ]
        # pylint: enable=unnecessary-lambda-assignment
        for gongan, value, expected in tests:
            with self.subTest(gongan_id=gongan.id):
                converter._apply_metadata(gongan)
                self.assertEqual(value(), expected)

    def test_move_beat_to_start1(self):
        # Test that the method is only called if beat_at_end is set.
        for getter in [self.get_converter_gk, self.get_converter_beat_at_end]:
            converter = getter()
            converter._move_beat_to_start = MagicMock(return_value=None)
            converter.run()
            if getter == self.get_converter_beat_at_end:
                converter._move_beat_to_start.assert_called_once()
            else:
                converter._move_beat_to_start.assert_not_called()

    def test_move_beat_to_start2(self):
        # Original score:
        #   gongan1: iuea
        #   gongan2: ioeu
        converter = self.get_converter_beat_at_end()
        converter.run()
        # Assert that the content of the first gongan was shifted by one note and that a silence
        # was added at the beginning.
        self.assertEqual(
            converter.score.gongans[0].beats[0].measures[Position.PEMADE_POLOS].passes[-1].notes,
            [P.SILENCE, P.DING1, P.DUNG1, P.DENG1],
        )
        # Assert that the content of the second gongan was shifted by one note
        # and that its first beat now contains the last note of the previous beat.
        self.assertEqual(
            converter.score.gongans[0].beats[1].measures[Position.PEMADE_POLOS].passes[-1].notes,
            [P.DANG1, P.DING1, P.DONG1, P.DONG1MUTED],
        )
        # Assert that the second gongan has a kempli beat, and that the status is 'autogenerated'
        self.assertTrue(Position.KEMPLI in converter.score.gongans[1].beats[0].measures.keys())
        self.assertEqual(
            converter.score.gongans[1].beats[0].measures[Position.KEMPLI].passes[-1].notes,
            [Ka.MUTEDSTRIKE, Ka.EXTENSION, Ka.EXTENSION, Ka.EXTENSION],
        )
        # Assert that a new gongan was created containing the last note of the previous
        # gongan and a kempli beat.
        self.assertEqual(len(converter.score.gongans), 3)
        self.assertEqual(
            converter.score.gongans[2].beats[0].measures[Position.PEMADE_POLOS].passes[-1].notes, [P.DANG0]
        )
        self.assertTrue(Position.KEMPLI in converter.score.gongans[2].beats[0].measures.keys())
        self.assertEqual(
            converter.score.gongans[2].beats[0].measures[Position.KEMPLI].passes[-1].notes,
            [Ka.MUTEDSTRIKE],
        )
