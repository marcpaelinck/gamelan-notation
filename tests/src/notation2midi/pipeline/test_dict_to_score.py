import unittest
from unittest.mock import MagicMock

from src.common.classes import Beat, Measure, Notation
from src.common.constants import DEFAULT, ParserTag, Position
from src.common.notes import Note
from src.notation2midi.classes import MetaDataRecord
from src.notation2midi.execution.execution import Score
from src.notation2midi.metadata_classes import MetaDataSwitch
from src.notation2midi.pipeline.notation_to_score import ScoreCreatorAgent
from src.settings.settings import Settings
from tests.conftest import BaseUnitTestCase
from tests.src.utils_for_tests import PositionNote

# pylint: disable=missing-module-docstring
# pylint: disable=missing-function-docstring
# pylint: disable=protected-access
# pylint: disable=invalid-name


P = PositionNote(Position.PEMADE_POLOS)
Pa = PositionNote(Position.PEMADE_POLOS, autogenerated=True)
S = PositionNote(Position.PEMADE_SANGSIH)
Sa = PositionNote(Position.PEMADE_SANGSIH, autogenerated=True)
J = PositionNote(Position.JEGOGAN)
Ja = PositionNote(Position.JEGOGAN, autogenerated=True)
C = PositionNote(Position.CALUNG)
Ca = PositionNote(Position.CALUNG, autogenerated=True)
Ka = PositionNote(Position.KEMPLI, autogenerated=True)


def create_beat(beat_id: int = 1, content: dict[PositionNote, list[Note]] = None):
    measures = {
        pn.position: Measure(
            position=pn.position,
            all_positions=pn.position,
            passes={DEFAULT: Measure.Pass(seq=-1, notesymbols=[note for note in measure])},
        )
        for pn, measure in content.items()
    }
    return Beat(
        id=beat_id,
        gongan_id=1,
        measures=measures,
    )


def get_notation():
    notation = {
        -1: {ParserTag.METADATA: [], ParserTag.COMMENTS: [], ParserTag.STAVES: []},
        1: {
            ParserTag.METADATA: [MetaDataRecord(metatype="KEMPLI", status=MetaDataSwitch.OFF, line=1)],
            ParserTag.COMMENTS: ["Gongan 1"],
            ParserTag.STAVES: [
                {
                    ParserTag.PASS: -1,
                    ParserTag.MEASURES: [["i", "u", "e", "a"]],
                    "EXPECTED": ["i", "u", "e", "a"],
                    ParserTag.POSITION: Position.PEMADE_POLOS,
                    ParserTag.ALL_POSITIONS: [Position.PEMADE_POLOS, Position.KANTILAN_POLOS],
                    ParserTag.LINE: 3,
                },
            ],
        },
        2: {
            ParserTag.METADATA: [],
            ParserTag.COMMENTS: ["Gongan 2"],
            ParserTag.STAVES: [
                {
                    ParserTag.PASS: -1,
                    ParserTag.MEASURES: [["i", "o", "e,?", "u/"]],
                    "EXPECTED": ["i", "o", "e,?", "u/"],
                    ParserTag.POSITION: Position.PEMADE_POLOS,
                    ParserTag.ALL_POSITIONS: [Position.PEMADE_POLOS, Position.KANTILAN_POLOS],
                    ParserTag.LINE: 3,
                },
            ],
        },
    }
    return notation


class TestDictToScoreConverter(BaseUnitTestCase):

    def setUp(self):
        pass

    def get_converter_gk(self):
        settings = Settings.get(notation_id="test-gongkebyar", part_id="full")
        mock_notation = MagicMock(spec=Notation)
        mock_notation.settings = settings
        mock_notation.notation_dict = get_notation()
        return ScoreCreatorAgent(settings, mock_notation)

    def test_create_score(self):
        converter = self.get_converter_gk()
        score = converter.run()
        self.assertIsInstance(score, Score)
        self.assertEqual(
            converter.score.gongans[0].beats[0].measures[Position.PEMADE_POLOS],
            converter.notation.notation_dict[1][ParserTag.BEATS][1][Position.PEMADE_POLOS],
        )

    def test_get_all_positions(self):
        notation_dict = {
            1: {
                ParserTag.STAVES: [
                    {
                        ParserTag.PASS: -1,
                        ParserTag.MEASURES: [],
                        ParserTag.POSITION: Position.UGAL,
                        ParserTag.ALL_POSITIONS: [Position.UGAL],
                        ParserTag.LINE: 1,
                    },
                    {
                        ParserTag.PASS: -1,
                        ParserTag.MEASURES: [],
                        ParserTag.POSITION: Position.CALUNG,
                        ParserTag.ALL_POSITIONS: [Position.CALUNG],
                        ParserTag.LINE: 1,
                    },
                ]
            },
            2: {
                ParserTag.STAVES: [
                    {
                        ParserTag.PASS: -1,
                        ParserTag.MEASURES: [],
                        ParserTag.POSITION: Position.JEGOGAN,
                        ParserTag.ALL_POSITIONS: [Position.JEGOGAN],
                        ParserTag.LINE: 1,
                    },
                    {
                        ParserTag.PASS: -1,
                        ParserTag.MEASURES: [],
                        ParserTag.POSITION: Position.GONGS,
                        ParserTag.ALL_POSITIONS: [Position.GONGS],
                        ParserTag.LINE: 1,
                    },
                ]
            },
        }
        converter = self.get_converter_gk()
        positions = converter._get_all_positions(notation_dict)
        expected_positions = {Position.UGAL, Position.CALUNG, Position.JEGOGAN, Position.GONGS}
        self.assertEqual(positions, expected_positions)

    def test_staves_to_beat(self):
        converter = self.get_converter_gk()
        converter.run()
        notation = get_notation()
        for gongan_id, gongan in notation.items():
            for stave_seq, stave in enumerate(gongan[ParserTag.STAVES]):
                for measure_seq, _ in enumerate(stave[ParserTag.MEASURES]):
                    with self.subTest(gongan=gongan_id, stave=stave_seq, measure=measure_seq):
                        self.assertEqual(
                            converter.score.gongans[gongan_id - 1]
                            .beats[measure_seq]
                            .measures[Position.PEMADE_POLOS]
                            .passes[-1]
                            .notesymbols,
                            stave["EXPECTED"],
                        )

    def test_add_missing_measures(self):
        # Add test for _add_missing_measure method
        pass

    def test_extend_measure(self):
        # Add test for _extend_measure method
        pass

    def test_complement_shorthand_pokok_measure(self):
        # Add test for _complement_shorthand_pokok_measure method
        pass

    def test_process_goto(self):
        # Add test for _process_goto method
        pass

    def test_process_sequences(self):
        pass

    def test_create_missing_measures(self):
        pass

    def test_init(self):
        # Test initialization with a mock Notation object
        pass
        # self.assertEqual(self.converter.notation, self.mock_notation)
        # self.assertEqual(
        #     self.converter.DEFAULT_VELOCITY, self.settings.midi.dynamics[self.settings.midi.default_dynamics]
        # )
        # self.assertEqual(self.converter.score.title, self.settings.notation.title)
        # self.assertEqual(self.converter.score.settings, self.mock_notation.settings)
        # self.assertEqual(
        #     self.converter.score.instrument_positions,
        #     self.converter._get_all_positions(self.mock_notation.notation_dict),
        # )


if __name__ == "__main__":
    unittest.main()
