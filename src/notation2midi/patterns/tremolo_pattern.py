from typing import override

from src.common.constants import PatternType, Stroke
from src.common.notes import Note, NoteFactory, Pattern
from src.notation2midi.patterns.pattern import PatternGenerator
from src.settings.classes import SettingsPatternInfo


class TremoloPatternGenerator(PatternGenerator):
    """Generates note sequences to implement Patterns such as tremolo.
    Adds the sequence to the `pattern` attribute of the Pattern."""

    NAME = "Tremolo and Accelerating Tremolo"

    @override
    def create_pattern(self, notes: list[Note]) -> None:
        """Generates the note sequence for a tremolo.
            TREMOLO: The duration and pitch will be that of the given note.
            TREMOLO_ACCELERATING: The pitch will be that of the given note(s), the duration will be derived
            from the TREMOLO_ACCELERATING_PATTERN.
            The generated notes are marked as 'autogenerated'. This value will be used when generating
            (PDF) notation from the score object.

                Args:
            measure (list[Note]): One or two notes on which to base the tremolo (piitch only)

        Returns:
            list[Note]: The resulting notes
        """
        tremolo: SettingsPatternInfo.TremoloInfo = self.patternsettings.tremolo
        curr_noteseq = 0

        while curr_noteseq < len(notes):
            # Search the measure for tremolo notes
            tremolo_patterns: list[Pattern] = []
            tremolo_noteseqs: list[int] = []
            if notes[curr_noteseq].effect not in (PatternType.TREMOLO, PatternType.TREMOLO_ACCELERATING):
                curr_noteseq += 1
                # updated_measure.append(note)
                continue
            tremolo_patterns.append(notes[curr_noteseq])
            tremolo_noteseqs.append(curr_noteseq)
            if (
                curr_noteseq < len(notes) - 1
                and notes[curr_noteseq].effect is PatternType.TREMOLO_ACCELERATING
                and notes[curr_noteseq + 1].effect is PatternType.TREMOLO_ACCELERATING
            ):
                # Two successive TREMOLO_ACCELERATING notes will be processed together
                tremolo_patterns.append(notes[curr_noteseq + 1])
                tremolo_noteseqs.append(curr_noteseq + 1)

            # Generate the tremolo pattern

            generated_notes = []

            if tremolo_patterns[0].effect is PatternType.TREMOLO:
                pattern = tremolo_patterns[0]
                nr_of_notes = round(pattern.note_value * tremolo.notes_per_quarternote)
                note_value = pattern.note_value / nr_of_notes
                attributes = pattern.model_dump() | {
                    Note.Fields.EFFECT: Stroke.OPEN,
                    Note.Fields.NOTE_VALUE: note_value,
                    Note.Fields.AUTOGENERATED: True,
                }
                generated_notes.extend([NoteFactory.create_note(**attributes) for _ in range(nr_of_notes)])
            elif tremolo_patterns[0].effect is PatternType.TREMOLO_ACCELERATING:
                durations = [i / self.midisettings.base_note_time for i in tremolo.accelerating_pattern]
                note_idx = 0  # Index of the next pattern to select from the `tremolo_patterns` list
                for _, (duration, velocity) in enumerate(zip(durations, tremolo.accelerating_velocity)):
                    attributes = tremolo_patterns[note_idx].model_dump()
                    attributes |= {
                        Note.Fields.EFFECT: Stroke.OPEN,
                        Note.Fields.NOTE_VALUE: duration,
                        Note.Fields.RELATIVE_VELOCITY: velocity,
                        Note.Fields.AUTOGENERATED: True,
                    }
                    generated_notes.append(NoteFactory.create_note(**attributes))
                    note_idx = (note_idx + 1) % len(tremolo_patterns)

            else:
                raise ValueError("Unexpected tremolo type %s." % tremolo_patterns[0].effect)

            # Assign the generated notes to the first pattern.
            tremolo_patterns[0].pattern.extend(generated_notes)
            curr_noteseq += len(tremolo_patterns)
