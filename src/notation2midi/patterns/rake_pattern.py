from typing import override

from src.common.constants import PatternType, Stroke
from src.common.notes import Note, NoteFactory, Pattern, Tone
from src.notation2midi.patterns.pattern import PatternGenerator
from src.notation2midi.rules.rule import Instrument
from src.settings.classes import SettingsPatternInfo


class RakePatternGenerator(PatternGenerator):
    """Generates note sequences for the RAKERIGHT and RAKELEFT pattern types.
    Adds the sequence to the `pattern` attribute of the Pattern."""

    NAME = "Rake left and right (gangsa only)"

    @override
    def create_pattern(self, notes: list[Note]) -> None:
        """Generates the rake left and rake right patterns."""
        rakesettings: SettingsPatternInfo.RakeInfo = self.patternsettings.rake

        for note in notes:
            if isinstance(note, Pattern) and note.effect in (PatternType.RAKE_LEFT, PatternType.RAKE_RIGHT):
                # Determine the tones that should be generated
                pos_range = Instrument.get_range(position=note.position, extended=True)
                try:
                    start_index = pos_range.index(Tone(pitch=note.pitch, octave=note.octave))
                except ValueError as exc:
                    raise ValueError(
                        "%s octave %s not in range of %s" % (note.pitch, note.octave, note.position.value)
                    ) from exc
                end_index = (
                    min(start_index + rakesettings.number_of_notes, len(pos_range))
                    if note.effect is PatternType.RAKE_RIGHT
                    else max(start_index - rakesettings.number_of_notes, -1)
                )
                step = 1 if note.effect is PatternType.RAKE_RIGHT else -1

                # Set the note attributes
                attributes = note.model_dump()
                attributes |= {
                    Note.Fields.EFFECT: Stroke.OPEN,
                    Note.Fields.NOTE_VALUE: 0.5 / abs(end_index - start_index),
                    Note.Fields.AUTOGENERATED: True,
                    Note.Fields.SUSTAIN_ON_NEXT_NOTE: True,
                }
                for index in range(start_index, end_index, step):
                    attr = attributes | {
                        Note.Fields.PITCH: pos_range[index].pitch,
                        Note.Fields.OCTAVE: pos_range[index].octave,
                    }
                    note.pattern.append(NoteFactory.create_note(**attr))
