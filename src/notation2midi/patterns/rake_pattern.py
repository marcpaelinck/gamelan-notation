from typing import override

from src.common.constants import PatternType, Pitch, Stroke, SustainType
from src.common.notes import Note, NoteFactory, Pattern, Tone
from src.notation2midi.patterns.pattern import PatternGenerator
from src.notation2midi.rules.rule import Instrument
from src.settings.classes import SettingsPatternInfo


class RakePatternGenerator(PatternGenerator):
    """Generates note sequences for the RAKERIGHT and RAKELEFT pattern types.
    Adds the sequence to the `pattern` attribute of the Pattern."""

    NAME = "Rake left and right (gangsa only)"

    @override
    def create_pattern(self, notes: list[Note]) -> None:
        """Generates the rake left and rake right patterns."""
        rakesettings: SettingsPatternInfo.RakeInfo = self.patternsettings.rake

        for note in notes:
            if isinstance(note, Pattern) and note.effect in (PatternType.RAKE_LEFT, PatternType.RAKE_RIGHT):
                # Determine the tones that should be generated
                pattern: Pattern = note
                pos_range = Instrument.get_range(position=pattern.position, extended=True)
                try:
                    first_note_index = pos_range.index(Tone(pitch=pattern.pitch, octave=pattern.octave))
                except ValueError as exc:
                    raise ValueError(
                        "%s octave %s not in range of %s" % (pattern.pitch, pattern.octave, pattern.position.value)
                    ) from exc
                last_note_index = (
                    min(first_note_index + rakesettings.number_of_notes, len(pos_range))
                    if pattern.effect is PatternType.RAKE_RIGHT
                    else max(first_note_index - rakesettings.number_of_notes, -1)
                )
                step = 1 if pattern.effect is PatternType.RAKE_RIGHT else -1

                # Set the note attributes
                note_value = rakesettings.duration_in_basenotes / rakesettings.number_of_notes
                attributes = pattern.model_dump()
                attributes |= {
                    Note.Fields.EFFECT: Stroke.OPEN,
                    Note.Fields.RELATIVE_VELOCITY: 0.7,
                    Note.Fields.NOTE_VALUE: note_value,
                    Note.Fields.AUTOGENERATED: True,
                    Note.Fields.SUSTAIN_TYPE: SustainType.SUSTAIN,
                }
                for index in range(first_note_index, last_note_index, step):
                    attr = attributes | {
                        Note.Fields.PITCH: pos_range[index].pitch,
                        Note.Fields.OCTAVE: pos_range[index].octave,
                    }
                    pattern.pattern.append(NoteFactory.create_note(**attr))
                # Add silences if the end of the instrument's range was reached before the end of the pattern
                for index in range(rakesettings.number_of_notes - abs(last_note_index - first_note_index)):
                    pattern.pattern.append(
                        NoteFactory.create_rest(
                            pattern.position, Pitch.EXTENSION, note_value=note_value, autogenerated=True
                        )
                    )
                # Add silence to increase duration to a base note value
                if rakesettings.duration_in_basenotes < 1:
                    rest = NoteFactory.create_rest(
                        note.position,
                        Pitch.EXTENSION,
                        note_value=1 - rakesettings.duration_in_basenotes,
                        autogenerated=True,
                    )
                    pattern.pattern.append(rest)
