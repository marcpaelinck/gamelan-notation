"""This is the module that actually generates the MIDI messages.
It is used by the MidiGenerator (score_to_midi module).
"""

from enum import Enum
from typing import override

from mido import Message, MetaMessage, MidiTrack, bpm2tempo, tempo2bpm
from mido.messages import BaseMessage

from src.common.classes import Note, Preset
from src.common.constants import InstrumentType, Pitch, Position, Stroke
from src.common.logger import get_logger
from src.settings.classes import RunSettings

logger = get_logger(__name__)


class TimeUnit(Enum):  # pylint: disable=missing-class-docstring
    TICK = 1
    NOTE = 2
    SECOND = 3


class MidiTrackX(MidiTrack):
    """Extends the mido.MidiTrack class. The track processes and stores the messages
    for one single channel (which in most cases corresponds with one instrument position).
    Generates MIDI messages and keeps track of the midi time (tick time).
    """

    name: str
    run_settings: RunSettings
    position: Position
    instrumenttype: InstrumentType
    channel: int
    port: int
    bank: int
    preset: int
    animate_helpinghand: bool
    # The next attribute keeps track of the end message of the last note.
    # The time of this message will be delayed if an extension note is encountered.
    last_note: Note = None
    last_helpinghand_msg: Message = None
    last_noteoff_msgs: list[Message] = []
    ticktime_last_message: int = 0
    current_ticktime: int = 0
    current_bpm: int = 0
    current_velocity: int

    def set_channel_bank_and_preset(self):
        """The rack_name message is auto-generated by the MidiTrack constructor.
        self.append(MetaMessage("track_name", name=self.name, time=0))"""
        self.append(MetaMessage(type="midi_port", port=self.port))
        # Note: MSB (control 0) seems to accept values larger than 127.
        self.append(Message(type="control_change", skip_checks=True, control=0, value=self.bank, channel=self.channel))
        self.append(Message(type="program_change", program=self.preset, channel=self.channel))
        # Do not set channel volume. It will be set in the online MIDI app.
        # self.append(
        #     Message(type="control_change", control=7, value=127 if self.channel > 4 else 127, channel=self.channel)
        # )

    def __init__(self, position: Position, preset: Preset, run_settings: RunSettings):
        super().__init__()
        self.name = position.value
        self.run_settings = run_settings
        self.position = position
        self.animate_helpinghand = position in run_settings.midiplayer.helpinghand
        self.channel = preset.channel
        self.port = preset.port
        self.bank = preset.bank
        self.preset = preset.preset
        self.current_velocity = run_settings.midi.dynamics[run_settings.midi.default_dynamics]
        self.msg_id = 0
        # unique id for helpinghand messages
        self.set_channel_bank_and_preset()
        self.update_tempo(60)  # set default tempo, needed for initial silence
        self.last_helpinghand_msg = self._append_helpinghand_message()

    @override
    def append(self, message: BaseMessage, **kwargs):
        """Appends a message and increments the tick time.
        Overrides the MidiTrack append method.
        Args:
            message (BaseMessage): message to append.
        """
        super().append(message, **kwargs)
        self.ticktime_last_message += message.time

    def append_all_and_clear(self, messages: list[Message]):
        """Appends a list of messages and removes them from the list.
        Args:
            messages (list[Message]): the list of messages
        """
        for msg in messages:
            msg.time = self.current_ticktime - self.ticktime_last_message
            self.append(msg)
        messages.clear()

    def total_tick_time(self):
        """Returns the total tick time in the track's message list."""
        return sum(msg.time for msg in self)

    def current_time_in_millis(self, until_msg: Message = None) -> int:
        """Calculates the total track time in milliseconds or the track time until the given message.

        Args:
            msg (Message, optional): Calculate time until this message. Defaults to None.

        Returns:
            _type_: time in milliseconds
        """
        time_in_millis = 0
        bpm = 120
        for msg in self:
            time_in_millis += msg.time * 60000 / (bpm * self.run_settings.midi.PPQ)
            if isinstance(msg, MetaMessage) and msg.type == "set_tempo":
                bpm = tempo2bpm(msg.tempo)
            if msg is until_msg:
                break
        return time_in_millis

    def update_tempo(self, new_bpm, debug=False):
        """Checks if the tempo of the current beat differs from the current tempo
        and appends a new tempo message if this is the case.

        Args:
            new_bpm (_type_): _description_
            debug (bool, optional): _description_. Defaults to False.
        """
        if debug:
            logger.info(
                "     midi_track: request received to change bpm to %s, current bpm=%s", new_bpm, self.current_bpm
            )
        if new_bpm != self.current_bpm:
            if debug:
                logger.info("                 setting metamessage with new tempo %s", new_bpm)
            self.append(
                MetaMessage(
                    "set_tempo", tempo=bpm2tempo(new_bpm), time=(self.current_ticktime - self.ticktime_last_message)
                )
            )
            self.current_bpm = new_bpm

    def update_dynamics(self, new_velocity):
        """Updates the current dynamics value"""
        self.current_velocity = new_velocity

    def units_to_ticks(self, value: int, unit: TimeUnit) -> int:
        "Converts a value from the given unit to ticks"
        match unit:
            case TimeUnit.SECOND:
                beats = round(self.current_bpm * value / 60)
                return beats * self.run_settings.midi.base_note_time * self.run_settings.midi.base_notes_per_beat
            case TimeUnit.NOTE:
                return round(value * self.run_settings.midi.base_note_time)
            case TimeUnit.TICK:
                return value
            case _:
                raise ValueError(f"Unexpected unit value {unit}")

    def extend_last_notes(self, value: int, unit: TimeUnit) -> None:
        """Modifies the duration of the last note or note group by adding the given value
        to their note_off message(s)."""
        # TODO Shouldn't we check that all note_off messages are simultaneous?
        for i in range(len(self) - 1, -1, -1):
            if self[i].type == "note_off":
                self[i].time += self.units_to_ticks(value, unit)
            else:
                break

    def increase_current_time(self, value: int, unit: TimeUnit) -> None:
        """Increases the 'current' time"""
        self.current_ticktime += self.units_to_ticks(value, unit)

    def comment(self, message: str) -> None:
        """Creates and appends a comment message"""
        self.append(MetaMessage("text", text=message))

    def marker(self, message: str) -> None:
        """Creates and appends a marker message"""
        self.append(MetaMessage("marker", text=message))

    def _grace_note_duration(self) -> int:
        """A grace note uses half of the duration of the previous note or rest,
        with a maximum of 0.5 units.
        Returns:
            int: Duration for the grace note (MIDI value)
        """
        max_duration = int(0.5 * self.run_settings.midi.base_note_time)
        tick_duration = min(int((self.current_ticktime - self.ticktime_last_message) / 2), max_duration)
        return tick_duration

    def _append_helpinghand_message(self):
        if not self.animate_helpinghand:
            return
        # Add a message to animate the 'helping hand' (moving arrow).
        # The pitch, octave and time_until values will be updated when the next note is processed.
        text = (
            "{"
            f'"id": {self.msg_id}, "type": "helpinghand", "position": "{self.position}", "channel": {self.channel}, '
            '"pitch": "{pitch}", "octave": {octave}, "timeuntil": {time_until}, "islast": {is_last}'
            "}"
        )
        self.msg_id += 1
        new_msg = MetaMessage("marker", text=text)
        self.append(new_msg)
        return new_msg

    def _update_prev_helpinghand_message(self, note: Note, is_last: bool = False):
        if not self.animate_helpinghand or not self.last_helpinghand_msg:
            return
        # Edit the previous helping hand message with the current note information.
        if is_last:
            pitch = "NONE"
            octave = 0
            time_until = 0
        else:
            pitch = note.pitch
            octave = note.octave
            time_until = self.current_time_in_millis() - self.current_time_in_millis(self.last_helpinghand_msg)
        text = self.last_helpinghand_msg.text
        text = (
            text.replace("{pitch}", f"{pitch}")
            .replace("{octave}", f"{octave}")
            .replace("{time_until}", f"{time_until}")
            .replace("{is_last}", str(is_last).lower())  # format for javascript
        )
        self.last_helpinghand_msg.text = text

    def finalize(self):
        """Removes the last helping hand message if it has not been updated."""
        if self.last_helpinghand_msg and "{time_until}" in self.last_helpinghand_msg.text:
            self._update_prev_helpinghand_message(note=None, is_last=True)
        if self.last_noteoff_msgs:
            self.append_all_and_clear(self.last_noteoff_msgs)

    def add_note(self, note: Note):
        """Converts a note into a midi event

        Args:
            position (Position): The instrument position playing the note.
            note (note): Note to be processed.

        Raises:
            ValueError: _description_
        """
        if not note.pitch == Pitch.NONE:
            # Set ON and OFF messages for actual note
            # In case of multiple midi notes, all notes should start and stop at the same time.
            for count, midivalue in enumerate(note.midinote):
                if note.stroke is Stroke.GRACE_NOTE:
                    # Use part of the duration of the previous note or rest (max 1/2 unit).
                    # Remark that the noteoff message of the preceding note has not been saved yet
                    # if the grace note immediately follows it.
                    grace_tick_duration = self._grace_note_duration()
                else:
                    grace_tick_duration = 0

                if count == 0:
                    # Grace notes have duration 0: they don't advance the current time but "eat up"
                    # a part of the previous note's duration. To achieve this, we shift the current time
                    # back to the start of the grace note before adding the grace note to the track.
                    # We then reset it to its former value.
                    self.increase_current_time(-grace_tick_duration, TimeUnit.TICK)

                # Append any delayed note_off messages before appending a new note_on message.
                self.append_all_and_clear(self.last_noteoff_msgs)
                self.append(
                    Message(
                        type="note_on",
                        note=midivalue,
                        velocity=self.current_velocity,
                        time=self.current_ticktime - self.ticktime_last_message,
                        channel=self.channel,
                    )
                )

                if count == 0:
                    # In case of a grace note: reset the current time to its former value.
                    self.increase_current_time(grace_tick_duration, unit=TimeUnit.TICK)
                    # Add helping hand message
                    new_helpinghand_msg = self._append_helpinghand_message()
                    self._update_prev_helpinghand_message(note)
                    self.last_helpinghand_msg = new_helpinghand_msg

            for count, midivalue in enumerate(note.midinote):
                # Do not append the note_off message to the track yet. It might be followed by extension 'notes'.
                self.last_noteoff_msgs.append(
                    Message(
                        type="note_off",
                        note=midivalue,
                        time=0,  # the time will be determined by the self.append method
                        channel=self.channel,
                    )
                )

            if note.rest_after:
                # if the note is abbreviated or muted, it can not be extended.
                self.append_all_and_clear(self.last_noteoff_msgs)
            self.increase_current_time(note.duration + note.rest_after, unit=TimeUnit.NOTE)
        # TODO next two ifs can now be combined
        elif note.stroke is Stroke.SILENCE:
            # Increment time since last note ended
            self.append_all_and_clear(self.last_noteoff_msgs)
            self.increase_current_time(note.rest_after, unit=TimeUnit.NOTE)
        elif note.stroke is Stroke.EXTENSION:
            # Extension of note duration: add duration to last note
            # If a SILENCE occurred previously, treat the EXTENSION as a SILENCE
            self.increase_current_time(note.duration, unit=TimeUnit.NOTE)
        else:
            raise ValueError(f"Unexpected note value {note.pitch} {note.octave} {note.stroke}")
