from mido import Message, MetaMessage, MidiTrack, bpm2tempo, tempo2bpm

from src.common.classes import Note, Preset
from src.common.constants import (
    DynamicLevel,
    InstrumentType,
    Pitch,
    Position,
    Stroke,
    Velocity,
)
from src.common.logger import get_logger
from src.settings.classes import RunSettings
from src.settings.settings import BASE_NOTE_TIME, BASE_NOTES_PER_BEAT

logger = get_logger(__name__)


class MidiTrackX(MidiTrack):
    name: str
    position: Position
    instrumenttype: InstrumentType
    channel: int
    port: int
    bank: int
    preset: int
    animate_helpinghand: bool
    PPQ: int  # pulses per quarternote
    # The next attribute keeps track of the end message of the last note.
    # The time of this message will be delayed if an extension note is encountered.
    last_note: Note = None
    last_helpinghand_msg: Message = None
    last_noteoff_msg: Message = None
    time_since_last_note_end: int = 0
    time_last_message: int = 0
    current_time: int = 0
    current_bpm: int = 0
    current_velocity: int
    current_signature: int = 0
    DYNAMICS_TO_VELOCITY: dict[DynamicLevel, Velocity]

    def set_channel_bank_and_preset(self):
        # The rack_name message is auto-generated by the MidiTrack constructor.
        # self.append(MetaMessage("track_name", name=self.name, time=0))
        self.append(MetaMessage(type="midi_port", port=self.port))
        # Note: MSB (control 0) seems to accept values larger than 127.
        self.append(Message(type="control_change", skip_checks=True, control=0, value=self.bank, channel=self.channel))
        self.append(Message(type="program_change", program=self.preset, channel=self.channel))
        # Do not set channel volume. It will be set in the online MIDI app.
        # self.append(
        #     Message(type="control_change", control=7, value=127 if self.channel > 4 else 127, channel=self.channel)
        # )

    def __init__(self, position: Position, preset: Preset, run_settings: RunSettings):
        super().__init__()
        self.name = position.value
        self.position = position
        self.animate_helpinghand = position in run_settings.midiplayer.helpinghand
        self.channel = preset.channel
        self.port = preset.port
        self.bank = preset.bank
        self.preset = preset.preset
        self.PPQ = run_settings.midi.PPQ
        self.DYNAMICS_TO_VELOCITY = run_settings.midi.dynamics
        self.current_velocity = run_settings.midi.dynamics[run_settings.midi.default_dynamics]
        self.msg_id = 0
        # unique id for helpinghand messages
        self.set_channel_bank_and_preset()
        # logger.info(f"Track {self.name}: channel {self.channel}, bank {self.bank}, preset {self.preset}")

    def total_tick_time(self):
        return sum(msg.time for msg in self)

    def current_time_in_millis(self, until_msg: Message = None) -> int:
        """Calculates the total track time in milliseconds or the track time until the given message.

        Args:
            msg (Message, optional): Calculate time until this message. Defaults to None.

        Returns:
            _type_: time in milliseconds
        """
        time_in_millis = 0
        bpm = 120
        for msg in self:
            time_in_millis += msg.time * 60000 / (bpm * self.PPQ)
            if isinstance(msg, MetaMessage) and msg.type == "set_tempo":
                bpm = tempo2bpm(msg.tempo)
            if msg is until_msg:
                break
        return time_in_millis

    def update_tempo(self, new_bpm, debug=False):
        if debug:
            logger.info(f"     midi_track: request received to change bpm to {new_bpm}, current bpm={self.current_bpm}")
        if new_bpm != self.current_bpm:
            if debug:
                logger.info(f"                 setting metamessage with new tempo {new_bpm}")
            self.append(MetaMessage("set_tempo", tempo=bpm2tempo(new_bpm), time=self.time_since_last_note_end))
            self.time_since_last_note_end = 0
            self.current_bpm = new_bpm

    def update_dynamics(self, new_velocity):
        self.current_velocity = new_velocity

    def extend_last_note(self, seconds: int) -> None:
        if self.last_noteoff_msg:
            beats = round(self.current_bpm * seconds / 60)
            self.last_noteoff_msg.time += beats * BASE_NOTE_TIME * BASE_NOTES_PER_BEAT

    def comment(self, message: str) -> None:
        self.append(MetaMessage("text", text=message))

    def marker(self, message: str) -> None:
        self.append(MetaMessage("marker", text=message))

    def _process_grace_note(self) -> int:
        """A grace note uses half of the duration of the previous note or rest,
        with a maximum of 0.5 units. This method modifies the last
        note_off message or the time_since_last_noteoff accordingly.
        Returns:
            int: Duration for the grace note (MIDI value)
        """
        MAX_DURATION = int(0.5 * BASE_NOTE_TIME)
        midi_duration = 0
        if self.time_since_last_note_end > 0:
            # subtract duration from preceding rest.
            midi_duration = min(int(self.time_since_last_note_end / 2), MAX_DURATION)
            self.time_since_last_note_end -= midi_duration
        else:
            # subtract duration from preceding note.
            midi_duration = int(self.last_note.duration * BASE_NOTE_TIME / 2) if self.last_note else MAX_DURATION
            self.last_noteoff_msg.time -= midi_duration
        return midi_duration

    def _append_helpinghand_message(self):
        if not self.animate_helpinghand:
            return
        # Add a message to animate the 'helping hand' (moving arrow).
        # The content (pitch, octave and time_until) will be updated when the next note is processed.
        text = f'{{"id": {self.msg_id}, "type": "helpinghand", "position": "{self.position}", "channel": {self.channel}, "pitch": "{{pitch}}", "octave": {{octave}}, "timeuntil": {{time_until}}}}'
        self.msg_id += 1
        new_msg = MetaMessage("marker", text=text)
        self.append(new_msg)
        return new_msg

    def _update_prev_helpinghand_message(self, note: Note):
        if not self.animate_helpinghand or not self.last_helpinghand_msg:
            return
        # Edit the previous helping hand message with the current note information.
        time_until = self.current_time_in_millis() - self.current_time_in_millis(self.last_helpinghand_msg)
        text = self.last_helpinghand_msg.text
        text = (
            text.replace("{pitch}", f"{note.pitch}")
            .replace("{octave}", f"{note.octave}")
            .replace("{time_until}", f"{time_until}")
        )
        self.last_helpinghand_msg.text = text

    def finalize(self):
        # Removes the last helping hand message if it has not been updated.
        if self.last_helpinghand_msg and "{time_until}" in self.last_helpinghand_msg.text:
            self.remove(
                self.last_helpinghand_msg
            )  # NOTE: Expecting that (the text of) this message is unique, otherwise the wrong message might be removed.

    def add_note(self, note: Note):
        """Converts a note into a midi event

        Args:
            position (Position): The instrument position playing the note.
            note (note): Note to be processed.

        Raises:
            ValueError: _description_
        """
        if not note.pitch == Pitch.NONE:
            # Set ON and OFF messages for actual note
            # In case of multiple midi notes, all notes should start and stop at the same time.
            for count, midivalue in enumerate(note.midinote):
                if note.stroke is Stroke.GRACE_NOTE:
                    # Use part of the duration of the previous note or rest (max 1/2 unit).
                    midi_duration = self._process_grace_note()
                else:
                    midi_duration = note.duration * BASE_NOTE_TIME
                self.append(
                    Message(
                        type="note_on",
                        note=midivalue,
                        velocity=self.current_velocity,
                        time=self.time_since_last_note_end if count == 0 else 0,  # all notes start together
                        channel=self.channel,
                    )
                )
                self.time_last_message += self.time_since_last_note_end
                if count == 0:
                    new_helpinghand_msg = self._append_helpinghand_message()
                    self._update_prev_helpinghand_message(note)
                    self.last_helpinghand_msg = new_helpinghand_msg

            for count, midivalue in enumerate(note.midinote):
                self.append(
                    off_msg := Message(
                        type="note_off",
                        note=midivalue,
                        time=round(midi_duration) if count == 0 else 0,  # all notes end together
                        channel=self.channel,
                    )
                )
                self.time_last_message += round(midi_duration)
                if count == 0:
                    # If the note corresponds with more than one MIDI note (e.g. reyong `byong`),
                    # we keep track of the note_off message of the first of these notes.
                    # If the combined note needs to be extended, we should only delay
                    # the note-off message of this first note.
                    # self._update_prev_helpinghand_message(note)
                    # self.last_helpinghand_msg = new_helpinghand_msg
                    self.last_noteoff_msg = off_msg

            self.time_since_last_note_end = round(note.rest_after * BASE_NOTE_TIME)
            self.last_note = note
        # TODO next two ifs can now be combined
        elif note.stroke is Stroke.SILENCE:
            # Increment time since last note ended
            self.time_since_last_note_end += round(note.rest_after * BASE_NOTE_TIME)
            self.last_noteoff_msg = None
        elif note.stroke is Stroke.EXTENSION:
            # Extension of note duration: add duration to last note
            # If a SILENCE occurred previously, treat the EXTENSION as a SILENCE
            if self.last_noteoff_msg and self.time_since_last_note_end == 0:
                self.last_noteoff_msg.time += round(note.duration * BASE_NOTE_TIME)
            else:
                self.time_since_last_note_end += round(note.duration * BASE_NOTE_TIME)
        else:
            raise ValueError(f"Unexpected note value {note.pitch} {note.octave} {note.stroke}")

        self.current_time += round((note.duration + note.rest_after) * BASE_NOTE_TIME)
