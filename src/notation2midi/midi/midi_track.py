"""This is the module that actually generates the MIDI messages.
It is used by the MidiGenerator (score_to_midi module).
"""

import json
from collections import defaultdict
from enum import Enum, StrEnum, auto
from typing import override

from mido import Message, MetaMessage, MidiTrack, bpm2tempo
from mido.messages import BaseMessage

from src.common.classes import Preset
from src.common.constants import InstrumentType, Pitch, Position, Stroke, SustainType
from src.common.logger import Logging
from src.common.notes import Note
from src.settings.classes import RunSettings

logger = Logging.get_logger(__name__)


class TimeUnit(Enum):  # pylint: disable=missing-class-docstring
    TICK = 1
    NOTE = 2
    SECOND = 3


class MidiTrackX(MidiTrack):
    """Extends the mido.MidiTrack class. The track processes and stores the messages
    for one single channel (which in most cases corresponds with one instrument position).
    Generates MIDI messages and keeps track of the midi time (tick time).
    """

    run_settings: RunSettings
    position: Position
    instrumenttype: InstrumentType
    channel: int
    port: int
    bank: int
    preset: int
    animate_helpinghand: bool
    first_helpinghand_msg: MetaMessage = None
    # The next attribute keeps track of the end message of the last note.
    # The time of this message will be delayed if an extension note is encountered.
    last_note: Note = None
    last_helpinghand_msg: MetaMessage = None
    # midi notes that are currently on (i.e. `note_off` message is not yet saved to the track)
    open_notes: dict[SustainType, set[int]] = defaultdict(set)
    ticktime_last_message: int = 0
    current_ticktime: int = 0
    # current and prev millitimes are used for the panggul animation
    current_millitime: int = 0  # cumulative time in milliseconds of the last message in the queue
    last_hh_millitime: int = 0  # idem for the most recent helpinghand message in the queue
    current_bpm: int = 0
    current_velocity: int
    TEMPO_TRACK_NAME = Position.KEMPLI.value  # Track that will hold the tempo MetaMessages.
    # Tempo changes need only to be set in one track because this is a type 1 MIDI file which synchronizes all tracks.

    def set_bank_and_preset(self):
        """Sets the preset. Call this method before any note on or note off message. This enables to assign multiple"
        tracks to the same channel."""
        # Note: MSB (control 0) seems to accept values larger than 127.
        self.append(Message(type="control_change", skip_checks=False, control=0, value=self.bank, channel=self.channel))
        self.append(Message(type="program_change", skip_checks=False, program=self.preset, channel=self.channel))
        self.append(MetaMessage(type="midi_port", port=self.port))

    def set_channel(self):
        """The track_name message is auto-generated by the MidiTrack constructor."""
        self.append(MetaMessage(type="midi_port", port=self.port))
        # Do not set channel volume. It will be set in the online MIDI app.

    def switch_note_on(self, midivalue: int, note: Note):
        """Sets the bank and preset before adding a note on message. This enables to assign multiple tracks
        to the same MIDI channel.
        Args:
            midivalue (int): the midi value for the message
            note (Note): Note object containing velocity information
            update_current_time: add the current message's duration to self.current_time
        """
        # self.set_bank_and_preset()
        self.append(
            Message(
                type="note_on",
                note=midivalue,
                velocity=int(self.current_velocity * note.relative_velocity),
                time=self.current_ticktime - self.ticktime_last_message,
                channel=self.channel,
                skip_checks=False,
            )
        )

    def __init__(self, position: Position, preset: Preset, midi_dict: dict, run_settings: RunSettings):
        super().__init__()
        self.name = position.value
        self.run_settings = run_settings
        self.position = position
        self.animate_helpinghand = position in run_settings.midiplayer.helpinghand
        self.channel = preset.channel
        self.port = preset.port
        self.bank = preset.bank
        self.preset = preset.preset
        self.current_velocity = run_settings.midi.dynamics[run_settings.midi.default_dynamics]
        self.msg_id = 0
        # unique id for helpinghand messages
        self.set_bank_and_preset()
        self.update_tempo(60)  # set default tempo, needed for initial silence
        self.last_helpinghand_msg = self._append_helpinghand_message()
        self.first_helpinghand_msg = self.last_helpinghand_msg
        self.midi_dict = midi_dict

    @override
    def append(self, message: BaseMessage, **kwargs):
        """Appends a message and increments the tick time.
        Overrides the MidiTrack append method.
        Args:
            message (BaseMessage): message to append.
        """
        super().append(message, **kwargs)
        self.ticktime_last_message += message.time

    def switch_notes_off(self, force: set[int] = None) -> None:
        """Appends note_off messages for currently playing notes and removes them from self.open_notes.
        Args:
           force: if True, all notes will be closed, including notes whose attribute sustain_on_next_note is True.
        """
        if force is None:
            force = set()
        # Keep track of already closed notes to avoid storing a note_off message twice for the same note
        # in the unlikely situation that the same note occurs both in the SUSTAIN and the DONT_SUSTAIN set.
        closed_notes = set()
        for sustaintype, midinotes in self.open_notes.items():
            for midivalue in sorted(list(midinotes)):  # sort set contents for predictable order: makes result testable.
                if (
                    sustaintype is SustainType.OFF_ON_NEXT_NOTE or midivalue in force
                ) and midivalue not in closed_notes:
                    self.append(
                        Message(
                            type="note_off",
                            note=midivalue,
                            time=self.current_ticktime - self.ticktime_last_message,
                            channel=self.channel,
                            skip_checks=False,
                        )
                    )
                    closed_notes.add(midivalue)
            self.open_notes[sustaintype] -= closed_notes
        # Remove notes that occurred in both sets from the SUSTAIN set.
        self.open_notes[SustainType.SUSTAIN] -= closed_notes

    def total_tick_time(self):
        """Returns the total tick time in the track's message list."""
        return sum(msg.time for msg in self)

    def update_tempo(self, new_bpm: int, debug: bool = False):
        """Checks if the tempo of the current beat differs from the current tempo
        and appends a new tempo message if this is the case.

        Args:
            new_bpm (int): _description_
            add_metamessage (bool): add a metamessage. If False, the current_bpm will be updated
                                    but no metamessage will be added to the track.
            debug (bool, optional): _description_. Defaults to False.
        """
        if debug:
            logger.info(
                "     midi_track: request received to change bpm to %s, current bpm=%s", new_bpm, self.current_bpm
            )
        if new_bpm != self.current_bpm:
            # Store all tempo messages in one channel. The 'safest' track is the KEMPLI track.
            # In other tracks tempo messages can cause an incorrect duration of grace notes at the beginning of a beat.
            if self.name == MidiTrackX.TEMPO_TRACK_NAME:
                if debug:
                    logger.info("                 setting metamessage with new tempo %s", new_bpm)
                self.append(
                    MetaMessage(
                        "set_tempo",
                        tempo=bpm2tempo(new_bpm),
                        time=(self.current_ticktime - self.ticktime_last_message),
                    )
                )

            self.current_bpm = new_bpm

    def update_dynamics(self, new_velocity):
        """Updates the current dynamics value"""
        if new_velocity != self.current_velocity:
            self.current_velocity = new_velocity

    def units_to_ticks(self, value: int, unit: TimeUnit) -> int:
        "Converts a value from the given unit to ticks"
        match unit:
            case TimeUnit.SECOND:
                beats = round(self.current_bpm * value / 60)
                return beats * self.run_settings.midi.base_note_time * self.run_settings.midi.base_notes_per_beat
            case TimeUnit.NOTE:
                return round(value * self.run_settings.midi.base_note_time)
            case TimeUnit.TICK:
                return value
            case _:
                raise ValueError(f"Unexpected unit value {unit}")

    def extend_last_notes(self, value: int, unit: TimeUnit) -> None:
        """Modifies the duration of the last note or note group by adding the given value
        to their note_off message(s)."""
        # TODO Shouldn't we check that all note_off messages are simultaneous?
        for i in range(len(self) - 1, -1, -1):
            if self[i].type == "note_off":
                self[i].time += self.units_to_ticks(value, unit)
            else:
                break

    def increase_current_time(self, value: int, unit: TimeUnit) -> None:
        """Increases the 'current' time"""
        tick_time = self.units_to_ticks(value, unit)
        self.current_ticktime += tick_time
        self.current_millitime += tick_time * 60000 / (self.current_bpm * self.run_settings.midi.PPQ)

    def comment(self, message: str) -> None:
        """Creates and appends a comment message"""
        self.append(MetaMessage("text", text=message))

    def marker(self, message: str) -> None:
        """Creates and appends a marker message"""
        self.append(MetaMessage("marker", text=message))

    def _grace_note_duration(self) -> int:
        """A grace note uses half of the duration of the previous note or rest,
        with a maximum of 0.5 units.
        Returns:
            int: Duration for the grace note (MIDI value)
        """
        max_duration = int(0.5 * self.run_settings.midi.base_note_time)
        tick_duration = min(int((self.current_ticktime - self.ticktime_last_message) / 2), max_duration)
        return tick_duration

    def _append_helpinghand_message(self):
        if not self.animate_helpinghand:
            return None
        # Add a message to animate the 'helping hand' (moving arrow).
        # The pitch, octave and time_until values will be updated when the next note is processed.
        text = (
            "{"
            f'"id": {self.msg_id}, "type": "helpinghand", "position": "{self.position}", "channel": {self.channel}, '
            '"pitch": "{pitch}", "octave": {octave}, "timeuntil": {time_until}, "islast": {is_last}'
            "}"
        )
        self.msg_id += 1
        new_msg = MetaMessage("marker", text=text)
        self.append(new_msg)
        return new_msg

    def _update_prev_helpinghand_message(self, note: Note, is_last: bool = False):
        if not self.animate_helpinghand or not self.last_helpinghand_msg:
            return
        # Edit the previous helping hand message with the current note information.
        if is_last:
            # if self.run_settings.notation.part.loop:
            first_msg_json = json.loads(self.first_helpinghand_msg.text)
            time_until = int(self.current_millitime - self.last_hh_millitime)
            pitch = first_msg_json["pitch"]
            octave = first_msg_json["octave"]
            time_until = first_msg_json["timeuntil"] + int(self.current_millitime - self.last_hh_millitime)
            # else:
            #     pitch = "NONE"
            #     octave = 0
            #     time_until = 0
        else:
            pitch = note.pitch
            octave = note.octave
            time_until = int(self.current_millitime - self.last_hh_millitime)
            self.last_hh_millitime = self.current_millitime
        text: str = self.last_helpinghand_msg.text
        text = (
            text.replace("{pitch}", f"{pitch}")
            .replace("{octave}", f"{octave}")
            .replace("{time_until}", f"{time_until}")
            .replace("{is_last}", str(is_last).lower())  # format for javascript
        )
        self.last_helpinghand_msg.text = text

    def finalize(self):
        """Removes the last helping hand message if it has not been updated."""
        if self.last_helpinghand_msg and "{time_until}" in self.last_helpinghand_msg.text:
            self._update_prev_helpinghand_message(note=None, is_last=True)
        self.switch_notes_off(force=self.open_notes[SustainType.SUSTAIN])

    def get_midinotes(self, note: Note) -> set[int]:
        """Return a list of midi values that correspond with the given Note object."""
        return self.midi_dict.get((note.position, note.pitch, note.octave, note.effect))

    def add_note(self, note: Note):
        """Converts a note into a midi event

        Args:
            position (Position): The instrument position playing the note.
            note (note): Note to be processed.

        Raises:
            ValueError: _description_
        """
        if note.pitch not in (Pitch.EXTENSION, Pitch.SILENCE):
            # sort set contents for predictable order: makes result testable.
            midinotes = sorted(list(self.get_midinotes(note)))
            # Stop all non-sustained notes and force stop any open midinote that occurs in the new note.
            grace_note_duration = 0
            if note.effect is Stroke.GRACE_NOTE:
                # Use part of the duration of the previous note or rest (max 1/2 unit).
                # Remark that the noteoff message of the preceding note has not been saved yet
                # if the grace note immediately follows it.
                # Grace notes have duration 0: they don't advance the current time but "eat up"
                # a part of the previous note's duration. To achieve this, we shift the current time
                # back to the start of the grace note before adding the grace note to the track.
                # We then reset it to its former value.
                grace_note_duration = self._grace_note_duration()
                self.increase_current_time(-grace_note_duration, TimeUnit.TICK)

            self.switch_notes_off(force=midinotes)
            # Set ON and OFF messages for actual note
            # In case of multiple midi notes, all notes should start and stop at the same time.
            for count, midivalue in enumerate(midinotes, start=1):

                # Add note_off messages of open notes before appending a new note_on message.
                # Update the current time after the last note_on message
                self.switch_note_on(midivalue=midivalue, note=note)

                if count == 1:
                    # Add helping hand message
                    new_helpinghand_msg = self._append_helpinghand_message()
                    self._update_prev_helpinghand_message(note)
                    self.last_helpinghand_msg = new_helpinghand_msg

                # Keep track of open notes in order to generate their note_off messages later.
                self.open_notes[note.sustaintype].add(midivalue)

            self.increase_current_time(grace_note_duration, TimeUnit.TICK)
            self.increase_current_time(note.duration, unit=TimeUnit.NOTE)
        # TODO next two ifs can now be combined
        elif note.pitch is Pitch.SILENCE:
            # Close all open notes and increment time since last note ended
            self.switch_notes_off(force=self.open_notes[SustainType.SUSTAIN])
            self.increase_current_time(note.duration, unit=TimeUnit.NOTE)
        elif note.pitch is Pitch.EXTENSION:
            # Extension of note duration: add duration to last note
            # If a SILENCE occurred previously, treat the EXTENSION as a SILENCE
            self.increase_current_time(note.duration, unit=TimeUnit.NOTE)
        else:
            raise ValueError(f"Unexpected note value {note.pitch} {note.octave} {note.effect}")
