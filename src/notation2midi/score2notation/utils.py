from reportlab.pdfbase.pdfmetrics import stringWidth

from src.common.classes import Gongan, Note
from src.common.constants import Pitch, Position, Stroke
from src.common.metadata_classes import GonganType, MetaDataSwitch
from src.notation2midi.notation_parser_tatsu import PassID


def measure_to_str(notes: list[Note]) -> str:
    """Converts the note objects to notation symbols.
    Replaces characters that are incompatible with HTML/XML content to compatible strings.
    Args:
        notes (list[Note]): Content that should be converted.
    Returns:
        str: HTML/XML compatible representation of the notation.
    """

    def get_symbol(note: Note):
        """enables to generate a modified symbol"""
        if note.stroke == Stroke.GRACE_NOTE:
            # Remove any stroke modifier character
            return note.symbol[0]
        return note.symbol

    if not notes:
        return ""
    notechars = (
        "".join(get_symbol(note) for note in notes).replace("&", "&amp;").replace("<", "&lt;").replace(">", "&gt;")
    )
    return notechars


def clean_staves(gongan: Gongan) -> dict[tuple[Position, PassID], list[list[Note]]]:
    """Converts a gongan into a dict. Removes autogenerated notes (e.g. created to emulate
    tremolo stroke or WAIT metadata).
    Also removes staves that are completely empty after removing autogenerated notes.
    Args:
        gongan (Gongan): The congan that should be 'cleaned'.
    Returns:
        dict[(Position, PassID), list[list[Note]]]: The gongan in tabular form.
    """
    if not gongan.beats:
        return dict()
    # create a dict (Position, PassID) -> list[list[Note]]
    # Make a list of beats containing only autogenerated notes. These will be skipped.
    skip_beats = set(
        beat.id
        for beat in gongan.beats
        if all(
            note.autogenerated
            for measure in beat.measures.values()
            for pass_ in measure.passes.values()
            for note in pass_.notes
        )
    )
    staves = {
        (position, passid): (
            [
                [note for note in beat.measures[position].passes[passid].notes if not note.autogenerated]
                for beat in gongan.beats
                if beat.id not in skip_beats
                if position in beat.measures
                if passid in beat.measures[position].passes
            ]
        )
        for position, measure in gongan.beats[0].measures.items()
        for passid in measure.passes.keys()
    }

    # Remove staves that are completely empty
    staves = {key: measures for key, measures in staves.items() if any(measure for measure in measures)}
    return staves


def string_width_from_notes(measure: list[Note], font_name: str, font_size: int) -> int:
    """Determines the width of a notation string. This function ignores diacritics which should have
       no effect on the note width. This avoids incorrect results from the stringWidth method which
       does not process multiple diacritic symbols correctly. This is possibly due to the use of negative
       character widths in the `Bali Font 5` font.
    Args:
        measure (list[Note]): Notes for which to determine the width of the notation.
        fontName (str):
        fontSize (int):
    Returns:
        int: the width in points.
    """
    # Select the first character of the note's symbol: this discards any diacritic character.
    return stringWidth("".join(n.symbol[0] if n.symbol else "" for n in measure), font_name, font_size)


def to_aggregated_tags(positions: list[Position]) -> list[str]:
    """Returns a lowercase value of the instrument names. This function is used
       to format the values of the `positions` parameter of metadata items.
    Args:
        positions (list[Position]):
    Returns:
        list[str]: list of lowercase values for the instrument names.
    """
    tags = set(pos.lower() for pos in positions)
    pemade = {Position.PEMADE_POLOS.lower(), Position.PEMADE_SANGSIH.lower()}
    kantilan = {Position.KANTILAN_POLOS.lower(), Position.KANTILAN_SANGSIH.lower()}
    gangsa = {"pemade", "kantilan"}
    # Aggregate pemade and kantilan if both appear in the position list.
    if pemade.issubset(tags):
        tags = tags.difference(pemade).union({"pemade"})
    if kantilan.issubset(tags):
        tags = tags.difference(kantilan).union({"kantilan"})
    if gangsa.issubset(tags):
        tags = tags.difference(gangsa).union({"gangsa"})
    return tags


def has_kempli_beat(gongan: Gongan) -> bool:
    """Determines if the gongan has a kempli beat.
    Args:
        gongan (Gongan):
    Returns:
        bool: True if there is a kempli beat, otherwise False
    """
    return not any(
        (meta.data.metatype == "KEMPLI" and meta.data.status is MetaDataSwitch.OFF)
        or (meta.data.metatype == "GONGAN" and meta.data.type is not GonganType.REGULAR)
        for meta in gongan.metadata
    )


def is_silent(gongan: Gongan, position: Position, passid: PassID) -> bool:  # here: gongan_to_records
    """True if all the measures for the position/passid combination contain only notes with
    EXTENSION and/or SILENCE Stroke values.
    """
    no_occurrence = sum((beat.get_notes(position, passid, none=[]) for beat in gongan.beats), []) == []
    all_rests = all(
        note.pitch == Pitch.NONE for beat in gongan.beats for note in beat.get_notes(position, passid, none=[])
    )
    return no_occurrence or all_rests


def aggregate_positions(gongan: Gongan) -> dict[tuple[Position, PassID], str]:
    """Returns a dict that maps positions to labels ('tags'). Groups certain positions with identical staves:
       GANGSA_P, GANGSA_S, GANGSA, REYONG_13, REYONG_24 and REYONG.
    Args:
        gongan (Gongan): gongan to convert

    Returns:
        dict[Position, list[str]]: The 'position-to-tag' dict.
    """

    # pos_pass_tags maps (position, pas) pairs to short tag values. It contains only the non-silent positions
    # that occur in the gongan. The pass number is appended to the tags of non-default passes that differ
    # from the default stave. The KEMPLI is omitted.
    pos_pass_combis = [
        (position, PassID(passid))
        for position, measure in gongan.beats[0].measures.items()
        if position != Position.KEMPLI
        for passid, pass_ in measure.passes.items()
        if not pass_.autogenerated
    ]
    pos_pass_tags = {
        (position, passid): position.shortcode + (f":{int(passid)}" if passid > 0 else "")
        for position, passid in sorted(
            list(pos_pass_combis), key=lambda x: x[0].sequence + (x[1] / 100 if x[1] > 0 else -x[1] / 10)
        )
    }

    # Remove empty staves
    for position, passid in list(pos_pass_tags.keys()):
        if is_silent(gongan, position, passid):
            del pos_pass_tags[position, passid]

    def same(notes1: list[Note], notes2: list[Note]) -> bool:
        return all(
            note1.pitch == note2.pitch
            and note1.octave == note2.octave
            and note1.stroke == note2.stroke
            and note1.duration == note2.duration
            and note1.rest_after == note2.rest_after
            and note1.velocity == note2.velocity
            for note1, note2 in zip(notes1, notes2)
        )

    def try_to_aggregate_pos(positions: list[Position], passid: PassID, aggregate_tag: str) -> bool:
        """Determines if the notation is identical for all of the given positions for the given pass.
        In that case, updates the pos_pass_tags dict.
        """
        # Check if all positions occur in the gongan after removing empty staves
        if not all((pos, passid) in pos_pass_tags.keys() for pos in positions):
            return False
        all_positions_have_same_notation = all(
            all(same(beat.get_notes(pos, passid), beat.get_notes(positions[0], passid)) for beat in gongan.beats)
            for pos in positions
        )
        if all_positions_have_same_notation:
            # Set the tag of the first position as the aggregate tag.
            pos_pass_tags[positions[0], passid] = aggregate_tag + (f":{int(passid)}" if passid > 0 else "")
            # Delete all other positions in the pos_tags dict.
            keys_to_delete = [(pos, pid) for pos, pid in pos_pass_tags.keys() if pos in positions[1:] and pid == passid]
            for pos, pid in keys_to_delete:
                del pos_pass_tags[pos, passid]
            return True
        return False

    def aggregate_passes() -> None:
        """Determines if the notation is identical for consecutive passes of the same position.
        In that case groups the passes and updates the pos_pass_tags dict.
        """
        # Create a dict {pos -> [passes]} for positions with multiple passes (excluding the DEFAULT pass).
        pos_pass_dict = {
            pos: [int(pass_id) for p, pass_id in pos_pass_tags if pass_id > 0 and p == pos] for pos, _ in pos_pass_tags
        }
        pos_pass_dict = {pos: passes for pos, passes in pos_pass_dict.items() if len(passes) > 1}

        for position, passes in pos_pass_dict.items():
            # create groups (size >1) of staves that are the same for consecutive passes
            groups = []
            first = passes[0]
            nextpass = None
            for currpass, nextpass in zip(passes, passes[1:]):
                if first != currpass and not all(
                    same(beat.get_notes(position, currpass), beat.get_notes(position, nextpass))
                    for beat in gongan.beats
                ):
                    # Reached last pass of a group with size >1.
                    groups.append([first, currpass])
                    first = nextpass
            # Create the last group if its size is >1.
            if nextpass == passes[-1] and first != nextpass:
                groups.append([first, nextpass])
            # Process the groups: keep only the first stave of each group and modify the pass indicator of its tag.
            for group in groups:
                pos_pass_tags[position, group[0]] = (
                    pos_pass_tags[position, group[0]].split(":")[0] + f":{group[0]}-{group[1]}"
                )
                for passid in range(group[0] + 1, group[1] + 1):
                    del pos_pass_tags[position, passid]

    # Try to aggregate positions that have the same notation.
    GANGSA_P = [Position.PEMADE_POLOS, Position.KANTILAN_POLOS]
    GANGSA_S = [Position.PEMADE_SANGSIH, Position.KANTILAN_SANGSIH]
    GANGSA = GANGSA_P + GANGSA_S
    REYONG_13 = [Position.REYONG_1, Position.REYONG_3]
    REYONG_24 = [Position.REYONG_2, Position.REYONG_4]
    REYONG = REYONG_13 + REYONG_24
    passids = set(pid for _, pid in pos_pass_combis)
    for passid in passids:
        if not try_to_aggregate_pos(GANGSA, passid, "GANGSA"):
            try_to_aggregate_pos(GANGSA_P, passid, "GANGSA_P")
            try_to_aggregate_pos(GANGSA_S, passid, "GANGSA_S")
        if not try_to_aggregate_pos(REYONG, passid, "REYONG"):
            try_to_aggregate_pos(REYONG_13, passid, "REYONG_13")
            try_to_aggregate_pos(REYONG_24, passid, "REYONG_24")

    aggregate_passes()
    return pos_pass_tags
