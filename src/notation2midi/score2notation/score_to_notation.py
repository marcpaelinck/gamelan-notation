import csv
from os import path

import pandas as pd

from src.common.classes import Gongan, Note, Score
from src.common.constants import ParserTag, Pitch, Position
from src.notation2midi.notation_parser_tatsu import PassID
from src.notation2midi.score2notation.utils import aggregate_positions, is_silent
from src.settings.constants import InstrumentFields


def notelist_to_string(notelist: list[Note]) -> str:  # here: gongan_to_records, test_utils
    return "".join((n.symbol for n in notelist if not n.autogenerated))


def gongan_to_records(gongan: Gongan) -> list[dict[Position | int, list[str]]]:
    """Converts a gongan to a dict containing the notation for the individual beats.

    Args:
        gongan (Gongan): gongan to convert
        skipemptylines (bool, optional): if true, positions without content (only rests) are skipped. Defaults to True.

    Returns:
        list[dict[Position | int, list[str]]]: _description_
    """
    pos_tags = aggregate_positions(gongan)

    result = (
        [{InstrumentFields.POSITION: ParserTag.COMMENTS, 1: comment} for comment in gongan.comments]
        + [
            {InstrumentFields.POSITION: ParserTag.METADATA, 1: metadata.data.model_dump_notation()}
            for metadata in gongan.metadata
        ]
        + [
            {
                InstrumentFields.POSITION: pos_tags.get((position, passid), position)
                + (f":{passid}" if passid > 0 else "")
            }
            | {beat.id: notelist_to_string(beat.get_notes(position)) for beat in gongan.beats}
            for (position, passid) in pos_tags.keys()
            if any(position in beat.measures for beat in gongan.beats)
            and not (is_silent(gongan=gongan, position=position, passid=passid))
        ]
        + [{InstrumentFields.POSITION: ""} | {beat.id: "" for beat in gongan.beats}]
    )

    return result


def score_to_notation_file(score: Score) -> None:  # score_validation
    """Converts a validated (and optionally corrected) score object back to the
       original notation format and saves it to file (.TSV).
    Args:
        score (Score): The score
    """
    score_dict = sum((gongan_to_records(gongan) for gongan in score.gongans), [])
    score_df = pd.DataFrame.from_records(score_dict)
    fpath, ext = path.splitext(score.settings.notation_filepath)
    filepath = fpath + "_CORRECTED" + ext
    score_df.to_csv(filepath, sep="\t", index=False, header=False, quoting=csv.QUOTE_NONE)
