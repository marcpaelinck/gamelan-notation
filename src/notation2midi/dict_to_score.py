"""Creates a midi file based on a notation file.
See ./data/README.md for more information about notation files and ./data/notation/test
for an example of a notation file.
Main method: convert_notation_to_midi()
"""

from dataclasses import _MISSING_TYPE, asdict
from statistics import mode

from pydantic import ValidationError

from src.common.classes import (
    Beat,
    Gongan,
    Instrument,
    Measure,
    Notation,
    Note,
    Score,
    Tone,
)
from src.common.constants import (
    DEFAULT,
    Duration,
    NotationDict,
    ParserTag,
    PassSequence,
    Pitch,
    Position,
    RuleType,
    RuleValue,
    Stroke,
    Velocity,
)
from src.common.metadata_classes import (
    AutoKempyungMeta,
    DynamicsMeta,
    GonganMeta,
    GonganType,
    GoToMeta,
    KempliMeta,
    LabelMeta,
    MetaData,
    MetaDataSwitch,
    OctavateMeta,
    PartMeta,
    RepeatMeta,
    Scope,
    SequenceMeta,
    SuppressMeta,
    TempoMeta,
    ValidationMeta,
    ValidationProperty,
    WaitMeta,
)
from src.notation2midi.classes import MetaDataRecord, NoteRecord, ParserModel
from src.notation2midi.special_notes_treatment import (
    generate_tremolo,
    update_grace_notes_octaves,
)
from src.settings.constants import NoteFields

# pylint incorrectly reports an error when Pydantic fields are pre-assigned with the Field function
# pylint disable = no - member


class DictToScoreConverter(ParserModel):
    """Parser that converts the results of the notation parser into a Score object.
    This parser uses 'knowledge' about the instruments and idiom of the music to interpret the notation.
    It also processes the metadata.
    """

    notation: Notation = None
    score: Score = None

    POSITIONS_EXPAND_MEASURES = [
        Position.UGAL,
        Position.CALUNG,
        Position.JEGOGAN,
        Position.GONGS,
        Position.KEMPLI,
    ]

    default_velocity: Velocity

    def __init__(self, notation: Notation):
        super().__init__(self.ParserType.SCOREGENERATOR, notation.settings)
        self.notation = notation
        self.default_velocity = self.run_settings.midi.dynamics[self.run_settings.midi.default_dynamics]

        self.score = Score(
            title=self.run_settings.notation.title,
            settings=notation.settings,
            instrument_positions=self._get_all_positions(notation.notation_dict),
        )

    def _get_all_positions(self, notation_dict: NotationDict) -> set[Position]:
        all_instruments = [
            p
            for gongan_id, gongan in notation_dict.items()
            if gongan_id > 0
            for beat_id, measures in gongan[ParserTag.BEATS].items()
            if isinstance(beat_id, int) and beat_id > 0
            for p in measures.keys()
        ]
        return set(all_instruments)

    def _has_kempli_beat(self, gongan: Gongan):
        return (
            not (kempli := gongan.get_metadata(KempliMeta)) or kempli.status != MetaDataSwitch.OFF
        ) and gongan.gongantype not in [GonganType.KEBYAR, GonganType.GINEMAN]

    def _move_beat_to_start(self) -> None:
        # If the last gongan is regular (has a kempli beat), create an additional gongan with an empty beat
        last_gongan = self.score.gongans[-1]
        if self._has_kempli_beat(last_gongan):
            new_gongan = Gongan(id=last_gongan.id + 1, beats=[], beat_duration=0)
            self.score.gongans.append(new_gongan)
            last_beat = last_gongan.beats[-1]
            new_beat = Beat(
                id=1,
                gongan_id=int(last_gongan.id) + 1,
                bpm_start={DEFAULT: last_beat.bpm_end[-1]},
                bpm_end={DEFAULT: last_beat.bpm_end[-1]},
                # velocity_start and velocity_end are dict[pass, dict[Position, Velocity]]
                velocities_start={DEFAULT: last_beat.velocities_end[DEFAULT].copy()},
                velocities_end={DEFAULT: last_beat.velocities_end[DEFAULT].copy()},
                duration=0,
                prev=last_beat,
            )
            last_beat.next = new_beat
            for position in last_beat.measures.keys():
                # autogenerated=False because the content originates from the source.
                new_beat.measures[position] = Measure.new(position=position, notes=[], autogenerated=False)
            new_gongan.beats.append(new_beat)

        # Iterate through the beats starting from the end.
        # Move the end note of each instrument in the previous beat to the start of the current beat.
        # TODO WARNING: Only the default passes are shifted. Shifting other passes correctly would make this
        # method much more complicated and error prone due to possible unexpected effects of GOTO and LABEL
        # metadata. Therefore notation with kempli beat at the end should be avoided.
        beat = self.score.gongans[-1].beats[-1]
        while beat.prev:
            for position, measure in beat.prev.measures.items():
                if notes := measure.passes[DEFAULT].notes:  # only consider default pass.
                    # move notes with a total of 1 duration unit
                    notes_to_move = []
                    while notes and sum((note.total_duration for note in notes_to_move), 0) < 1:
                        notes_to_move.insert(0, notes.pop())
                    if not position in beat.measures:
                        # autogenerated=False because the content originates from the source.
                        beat.measures[position] = Measure.new(position=position, notes=[], autogenerated=False)
                    beat.get_pass(position, DEFAULT).notes[0:0] = notes_to_move  # insert at beginning
                    # Set autogenerated to False: the content is no longer (fully) autogenerated
                    # This is not very clear code. However notation with beat at the end is discouraged
                    # so don't want to spend too much time on this part.
                    beat.get_pass(position, DEFAULT).autogenerated = False
            # update beat and gongan duration values
            beat.duration = mode(
                sum(note.total_duration for note in measure.passes[DEFAULT].notes)
                for measure in list(beat.measures.values())
            )
            gongan = self.score.gongans[beat.gongan_seq]
            gongan.beat_duration = mode(beat.duration for beat in gongan.beats)
            beat = beat.prev

        # Add a rest at the beginning of the first beat
        for position, measure in self.score.gongans[0].beats[0].measures.items():
            measure.passes[DEFAULT].notes.insert(0, Note.get_whole_rest_note(position, Stroke.SILENCE))

    def _create_rest_notes(self, position: Position, resttype: Stroke, duration: float) -> list[Note]:
        """Creates a measure with rests of the given type for the given duration.
        If the duration is non-integer, the stameasureve will also contain half and/or quarter rests.

        Args:
            resttype (Stroke): the type of rest (SILENCE or EXTENSION)
            duration (float): the duration, which can be non-integer.

        Returns:
            list[Note]: _description_
        """
        # TODO exception handling
        notes = []
        whole_rest: Note = Note.get_whole_rest_note(position, resttype)
        for _ in range(int(duration)):
            notes.append(whole_rest.model_copy(update={"autogenerated": True}))

        # if duration is not integer, add the fractional part as an extra rest.
        if frac_duration := duration - int(duration):
            attribute = "duration" if whole_rest.duration > 0 else "rest_after"
            notes.append(whole_rest.model_copy(update={attribute: frac_duration, "autogenerated": True}))

        return notes

    def _create_rest_measure(
        self, position: Position, resttype: Stroke, duration: float, pass_seq: PassSequence = DEFAULT
    ) -> Measure:
        notes = self._create_rest_notes(position=position, resttype=resttype, duration=duration)
        return Measure.new(position=position, notes=notes, pass_seq=pass_seq, autogenerated=True)

    def _create_rest_measures(
        self,
        prev_beat: Beat,
        positions: list[Position],
        duration: Duration,
        force_silence: list[Position] = None,
        pass_seq: PassSequence = DEFAULT,
    ):
        silence = Stroke.SILENCE
        extension = Stroke.EXTENSION
        prevstrokes = {
            # We select the default pass because pass_seq might not be the corresponding sequence in prev_beat
            # as a consequence of the flow of the score that will be created in a later stage.
            pos: (prev_beat.get_notes(pos, DEFAULT)[-1].stroke if prev_beat else silence)
            for pos in positions
        }
        # Remark: the resttype is EXTENSION if the previous stroke is MUTED or ABBREVIATED.
        # This will avoid undesired muting when a GOTO points to this measure.
        resttypes = {
            pos: silence if prevstroke is silence or pos in (force_silence or []) else extension
            for pos, prevstroke in prevstrokes.items()
        }
        return {
            position: self._create_rest_measure(
                position=position, resttype=resttypes[position], duration=duration, pass_seq=pass_seq
            )
            for position in positions
        }

    def _note_from_rec(
        self,
        note_record: NoteRecord,
        position: Position,
        all_positions: list[Position],
        metadata: list[MetaData],
    ) -> "Note":
        """Casts the given NoteRecord objevct to a Note object which is bound to a Position.
        If multiple positions share the same notation this method applies rules
        (e.g. octavation or kempyung) to cast the NoteRecord to the correct Note for the given position.
        Args:
            symbol (str): notation characters.
            position (Position): position to match.
            unisono_positions (list[Position]): positions that share the same notation.
        Returns:
            Note: _description_
        """
        if len(all_positions) == 1:
            # Notation for single position
            if position not in all_positions:
                raise ValueError(f"{position} not in list {all_positions}")
            note = Note.get_note(
                position,
                pitch=note_record.pitch,
                octave=note_record.octave,
                stroke=note_record.stroke,
                duration=note_record.duration,
                rest_after=note_record.rest_after,
            )
            if not note:
                # Most common error is wrong octave. Find similar symbols with the correct octave.
                any_oct_symbol = note_record + ",<"
                alternatives = [
                    n.symbol
                    for n in Note.VALIDNOTES
                    if n.position is position and all(char in any_oct_symbol for char in n.symbol)
                ]
                msg1 = "Invalid note '%s' for %s." % (note_record.symbol, position)
                msg2 = " Did you mean '%s'?" % ("or '".join(alternatives)) if alternatives else ""
                raise ValueError(msg1 + msg2)
            return note

        # The notation is for multiple positions. Determine pitch and octave using the 'unisono rules'.

        # Create a Tone object from the the symbol by finding any matching note (disregarding the position)
        reference_tone = Tone(note_record.pitch, note_record.octave)
        tone = Instrument.cast_to_position(
            tone=reference_tone, position=position, all_positions=set(all_positions), metadata=metadata
        )

        # Return the matching note within the position's range
        if tone:
            note = Note.get_note(
                position=position,
                pitch=tone.pitch,
                octave=tone.octave,
                stroke=note_record.stroke,
                duration=note_record.duration,
                rest_after=note_record.rest_after,
            )
            return note.model_copy_x(transformation=tone.transformation)
        else:
            # return silence
            note = Note.get_note(
                position=position,
                pitch=Pitch.NONE,
                octave=None,
                stroke=Stroke.SILENCE,
                duration=0,
                rest_after=note_record.duration + note_record.rest_after,
            )
            return note
            # raise ValueError("Could not find an equivalent for %s for %s}" % (note_record.symbol, position))

    def _convert_to_notes(
        self,
        noterecord_list: list[NoteRecord],
        position: Position,
        all_positions: list[Position],
        metadata: list[MetaData],
    ) -> list[Note]:
        """Converts the generic NoteRecord objects to position bound Note objects.
            Applies rules to transform the note to the correct value for the given position (e.g. kempyung, octavation).
            Updates the octave of grace notes.
            Converts tremolo notes to a pattern of Note objects.

           If the stave stands for multiple reyong positions, the notation is transformed to match
           each position separately. There are two possible cases:
            - REYONG_1 and REYONG_3 are combined: the notation is expected to represent the REYONG_1 part
              and the score is octavated for the REYONG_3 position.
            - REYONG_2 and REYONG_4: similar case. The notation should represent the REYONG_2 part.
            - All reyong positions: the notation is expected to represent the REYONG_1 part.
              In this case the kempyung equivalent of the notation will be determined for REYONG_2
              and REYONG_4 within their respective range.

        Args:
            stave (str): one stave of notation
            position (Position):
            multiple_positions (list[Position]): List of all positions for this stave.

        Returns: str | None: _description_
        """
        notes = []  # will contain the Note objects
        for note_rec in noterecord_list:
            # try parsing the next note
            # next_note = Note.parse_next_note(note_chars, position)
            try:
                next_note = self._note_from_rec(note_rec, position, all_positions, metadata=metadata)
            except ValueError as e:
                self.logerror(str(e))
            if not next_note:
                self.logerror(f"Could not cast {note_rec[NoteFields.SYMBOL]} to {position.value}")
            else:
                notes.append(next_note)
        try:
            notes = update_grace_notes_octaves(measure=notes)
            notes = generate_tremolo(measure=notes, midi_settings=self.run_settings.midi, errorlogger=self.logerror)
        except ValueError as e:
            self.logerror(str(e))
        return notes

    def _apply_metadata(self, gongan: Gongan) -> None:
        """Processes the metadata of a gongan into the object model.

        Args:
            metadata (list[MetaData]): The metadata to process.
            gongan (Gongan): The gongan to which the metadata applies.
        """

        def process_goto(gongan: Gongan, goto: MetaData) -> None:
            for rep in goto.data.passes:
                gongan.beats[goto.data.beat_seq].goto[rep] = self.score.flowinfo.labels[
                    goto.data.label
                ]  # TODO GOTO REMOVE
                goto_item = Beat.GoTo(
                    beat=self.score.flowinfo.labels[goto.data.label],
                    passes=goto.data.passes,
                    frequency=goto.data.frequency,
                )
                gongan.beats[goto.data.beat_seq].goto_[rep] = goto_item

        metadata = gongan.metadata.copy() + self.score.global_metadata
        haslabel = False  # Will be set to true if the gongan has a metadata Label tag.
        for meta in sorted(metadata, key=lambda x: x.data.processingorder):
            self.curr_line_nr = meta.data.line
            match meta.data:
                case GonganMeta():
                    # TODO: how to safely synchronize all instruments starting from next regular gongan?
                    gongan.gongantype = meta.data.type
                    if gongan.gongantype in [GonganType.GINEMAN, GonganType.KEBYAR]:
                        for beat in gongan.beats:
                            beat.has_kempli_beat = False
                case GoToMeta():
                    # Add goto info to the beat
                    if self.score.flowinfo.labels.get(meta.data.label, None):
                        process_goto(gongan, meta)
                    else:
                        # Label not yet encountered: store GoTo obect in flowinfo
                        self.score.flowinfo.gotos[meta.data.label].append((gongan, meta))
                case KempliMeta():
                    # Suppress kempli.
                    # TODO status=ON will never be used because it is the default. So attribute status can be discarded.
                    # Unless a future version enables to switch kempli off until a Kempli ON tag is encountered.
                    if meta.data.status is MetaDataSwitch.OFF:
                        for beat in gongan.beats:
                            # Default is all beats
                            if beat.id in meta.data.beats or not meta.data.beats:
                                beat.has_kempli_beat = False
                case AutoKempyungMeta():
                    # This metadata item is used in Instrument.cast_to_position to select the correct casting method.
                    continue
                case LabelMeta():
                    # Add the label to flowinfo
                    haslabel = True
                    self.score.flowinfo.labels[meta.data.name] = gongan.beats[meta.data.beat_seq]
                    # Process any GoTo pointing to this label
                    goto: MetaData
                    for gongan_, goto in self.score.flowinfo.gotos[meta.data.name]:
                        process_goto(gongan_, goto)
                case OctavateMeta():
                    for beat in gongan.beats:
                        if meta.data.instrument in beat.measures.keys():
                            for pass_ in self.pass_iterator(beat.measures[meta.data.instrument]):
                                notes = pass_.notes
                                for idx, note in enumerate(notes):
                                    if note.octave is not None:
                                        oct_note = Note.get_note(
                                            note.position,
                                            note.pitch,
                                            note.octave + meta.data.octaves,
                                            note.stroke,
                                            note.duration,
                                            note.rest_after,
                                        )
                                        if oct_note:
                                            notes[idx] = oct_note
                                        else:
                                            self.logerror(
                                                "could not octavate note %s%s with %s octave for %s."
                                                % (note.pitch, note.octave, meta.data.octaves, meta.data.instrument)
                                            )
                case PartMeta():
                    pass
                case RepeatMeta():
                    gongan.beats[-1].repeat = Beat.Repeat(goto=gongan.beats[0], iterations=meta.data.count)
                case SequenceMeta():
                    self.score.flowinfo.sequences.append((gongan, meta.data))
                case SuppressMeta():
                    # Silences the given positions for the given beats and passes.
                    # This is done by adding pass(es) with SILENCE Notes.
                    for beat in gongan.beats:
                        # If no beats are given, default is all beats
                        if beat.id in meta.data.beats or not meta.data.beats:
                            for position in meta.data.positions:
                                if not position in beat.measures.keys():
                                    self.logwarning(
                                        f"Position {position} of {SuppressMeta.metatype} instruction not in gongan."
                                    )
                                    continue
                                line = beat.measures[position].passes[DEFAULT].line
                                for pass_seq in meta.data.passes:
                                    notes = self._create_rest_notes(position, Stroke.EXTENSION, beat.duration)
                                    beat.measures[position].passes[pass_seq] = Measure.Pass(
                                        seq=pass_seq, line=line, notes=notes, autogenerated=True
                                    )
                case TempoMeta() | DynamicsMeta():
                    changetype = (
                        Beat.Change.Type.TEMPO if isinstance(meta.data, TempoMeta) else Beat.Change.Type.DYNAMICS
                    )
                    if (
                        first_too_large := meta.data.first_beat > len(gongan.beats)
                    ) or meta.data.first_beat + meta.data.beat_count - 1 > len(gongan.beats):
                        value = "first_beat" + (" + beat_count" if not first_too_large else "")
                        self.logerror(f"{meta.data.metatype} metadata: {value} is larger than the number of beats")
                        continue
                    if meta.data.beat_count == 0:
                        # immediate change.
                        beat = gongan.beats[meta.data.first_beat_seq]
                        beat.changes[changetype].update(
                            {
                                pass_seq: Beat.Change(
                                    new_value=meta.data.value,
                                    positions=meta.data.positions if changetype == Beat.Change.Type.DYNAMICS else [],
                                    incremental=False,
                                )
                                for pass_seq in meta.data.passes
                            }
                        )
                    else:
                        # Stepwise change over meta.data.beats beats. The first change is after first beat.
                        # This emulates a gradual tempo change.
                        beat = gongan.beats[meta.data.first_beat_seq]
                        steps = meta.data.beat_count
                        for _ in range(meta.data.beat_count):
                            beat = beat.next
                            if not beat:  # End of score. This should not happen unless notation error.
                                break
                            beat.changes[changetype].update(
                                {
                                    pass_seq: Beat.Change(
                                        new_value=meta.data.value,
                                        steps=steps,
                                        positions=(
                                            meta.data.positions if changetype == Beat.Change.Type.DYNAMICS else []
                                        ),
                                        incremental=True,
                                    )
                                    for pass_seq in meta.data.passes
                                }
                            )
                            steps -= 1
                case ValidationMeta():
                    for beat in [b for b in gongan.beats if b.id in meta.data.beats] or gongan.beats:
                        beat.validation_ignore.extend(meta.data.ignore)
                case WaitMeta():
                    # Add a beat with silences at the end of the gongan.
                    # The beat's bpm is set to 60 for easy calculation.
                    lastbeat = gongan.beats[-1]
                    duration = round(4 * meta.data.seconds)  # 4 notes per bpm unit and bpm=60 => 4 notes per second.
                    newbeat = Beat(
                        id=lastbeat.id + 1,
                        gongan_id=gongan.id,
                        bpm_start={-1: 60},
                        bpm_end=lastbeat.bpm_end,
                        velocities_start=lastbeat.velocities_start.copy(),
                        velocities_end=lastbeat.velocities_end.copy(),
                        duration=duration,
                        prev=lastbeat,
                        next=lastbeat.next,
                        has_kempli_beat=False,
                        validation_ignore=[ValidationProperty.BEAT_DURATION],
                    )
                    if lastbeat.next:
                        # modify the default next and prev pointes
                        lastbeat.next.prev = newbeat
                        lastbeat.next = newbeat
                        # move goto pointers to the end of the wait beat
                        # TODO GOTO REMOVE next 5 lines
                        for rep, beat in lastbeat.goto.items():
                            if rep in meta.data.passes:
                                newbeat.goto[rep] = beat
                                del lastbeat.goto[rep]
                        lastbeat.goto = dict()
                        for rep, goto in lastbeat.goto_.items():
                            if rep in meta.data.passes:
                                newbeat.goto_[rep] = goto
                                del lastbeat.goto_[rep]
                        lastbeat.goto_ = dict()
                    newbeat.measures = self._create_rest_measures(
                        prev_beat=lastbeat, positions=list(lastbeat.measures.keys()), duration=duration
                    )
                    gongan.beats.append(newbeat)
                case _:
                    raise ValueError("Metadata type %s is not supported." % type(meta.data).__name__)

        if haslabel:
            # Gongan has one or more Label metadata items: explicitly set the current tempo for each beat by copying it
            # from its predecessor. This will ensure that a goto to any of these beats will pick up the correct tempo.
            for beat in gongan.beats:
                if not beat.changes and beat.prev:
                    beat.changes.update(beat.prev.changes)

    def _process_sequences(self):
        """Translates the labels of the SEQUENCE metadata into goto directives in the respective beats."""
        for initial_gongan, sequence in self.score.flowinfo.sequences:
            gongan = initial_gongan
            for label in sequence.value:
                from_beat = gongan.beats[-1]  # Sequence always links last beat to first beat of next gongan in the list
                to_beat = self.score.flowinfo.labels[label]
                # TODO GOTO modify, also for frequency = ALWAYS
                pass_nr = max([p for p in from_beat.goto.keys()] or [0]) + 1  # Select next available pass
                from_beat.goto[pass_nr] = to_beat  # TODO GOTO delete
                from_beat.goto_[pass_nr] = Beat.GoTo(beat=to_beat, passes=[pass_nr], frequency=sequence.frequency)
                gongan = self.score.gongans[to_beat.gongan_seq]

    @classmethod
    def _kempli_beat(cls) -> Note:
        # a kempli beat is a muted stroke
        return Note.get_note(
            Position.KEMPLI,
            pitch=Pitch.STRIKE,
            octave=None,
            stroke=Stroke.MUTED,
            duration=1,
            rest_after=0,
        ).model_copy(update={"autogenerated": True})

    def _create_missing_measures(
        self, beat: Beat, prevbeat: Beat, all_instruments: list[Position], force_silence=None
    ) -> dict[Position, Measure]:
        """Returns measures for missing positions, containing rests (silence) for the duration of the given beat.
        This ensures that positions that do not occur in all the gongans will remain in sync.
        Args:
            beat (Beat): The beat that should be complemented.
            all_positions (set[Position]): List of all the positions that occur in the notation.
        Returns:
            dict[Position, Measure]: A dict with the generated measures.
        """

        # add rests to existing but empty measures
        for position, measure in beat.measures.items():
            for pass_ in measure.passes.values():
                if not pass_.notes:
                    resttype = (
                        Stroke.SILENCE
                        if (force_silence and position in force_silence)
                        or prevbeat.get_notes(position, DEFAULT)[-1].stroke is Stroke.SILENCE
                        else Stroke.EXTENSION
                    )
                    pass_.notes = self._create_rest_notes(position=position, resttype=resttype, duration=beat.duration)
        # add measures for missing positions
        if missing_positions := (all_instruments - set(pos for pos in beat.measures.keys() if beat.measures[pos])):
            measures = self._create_rest_measures(
                prev_beat=prevbeat, positions=missing_positions, duration=beat.duration, force_silence=force_silence
            )

            # Add a kempli beat, except if a metadata label indicates otherwise
            # or if the kempli part was already given in the original score
            if Position.KEMPLI in measures.keys():  # and has_kempli_beat(gongan):
                if beat.has_kempli_beat:
                    rests = self._create_rest_notes(Position.KEMPLI, Stroke.EXTENSION, beat.duration - 1)
                    measures[Position.KEMPLI] = Measure.new(
                        position=Position.KEMPLI, notes=[self._kempli_beat()] + rests, autogenerated=True
                    )
                else:
                    measures[Position.KEMPLI] = self._create_rest_measure(
                        Position.KEMPLI, Stroke.EXTENSION, beat.duration
                    )

            return measures
        else:
            return dict()

    def _add_missing_measures(self, add_kempli: bool = True):
        prev_beat = None
        for gongan in self.gongan_iterator(self.score):
            all_instruments = self.score.instrument_positions | (
                {Position.KEMPLI} if add_kempli else self.score.instrument_positions
            )
            gongan_missing_instr = [
                pos for pos in all_instruments if all(pos not in beat.measures for beat in gongan.beats)
            ]
            for beat in self.beat_iterator(gongan):
                # Not all positions occur in each gongan.
                # Therefore we need to add blank measure (all rests) for missing positions.
                # If an instrument is missing in the entire gongan, the last beat should consist
                # of silences (.) rather than note extensions (-). This avoids unexpected results when the next beat
                # is repeated and the kempli beat is at the end of the beat.
                force_silence = gongan_missing_instr if beat == gongan.beats[-1] else []
                missing_measures = self._create_missing_measures(
                    beat, prev_beat, all_instruments, force_silence=force_silence
                )
                beat.measures.update(missing_measures)
                # Update all positions of the score
                self.score.instrument_positions.update({pos for pos in missing_measures})
                prev_beat = beat

    def _extend_measure(self, position: Position, notes: list[Note], duration: float):
        """Extend a measure with EXTENSION notes so that its length matches the required duration.

        Args:
            position (Position): instrument position
            notes (list[Note]): the measure content that should be extended
            duration (float): target duration
        """
        filler = Note.get_whole_rest_note(position, Stroke.EXTENSION)
        measure_duration = sum(note.total_duration for note in notes)
        # Add rests of duration 1 to match the integer part of the beat's duration
        if int(duration - measure_duration) >= 1:
            try:
                fill_content = [
                    filler.model_copy(update={"autogenerated": True}) for count in range(int(duration - len(notes)))
                ]
                if self.score.settings.notation.beat_at_end:
                    fill_content.extend(notes)
                    notes.clear()
                    notes.extend(fill_content)
                else:
                    notes.extend(fill_content)
                measure_duration = sum(note.total_duration for note in notes)
            except ValidationError:
                self.logerror(
                    "Could not add rest to beat %s-%s of %s", self.curr_gongan_id, self.curr_beat_id, position
                )
        # Add an extra rest for any fractional part of the beat's duration
        if measure_duration < duration:
            attr = "duration" if filler.stroke == Stroke.EXTENSION else "rest_after"
            try:
                notes.append(filler.model_copy(update={attr: duration - measure_duration, "autogenerated": True}))
            except ValidationError:
                self.logerror(
                    "Could not add rest to beat %s-%s of %s", self.curr_gongan_id, self.curr_beat_id, position
                )

    def _complement_shorthand_pokok_measures(self):
        """Adds EXTENSION notes to pokok measures that only contain one note (shorthand notation)"""

        for gongan in self.gongan_iterator(self.score):
            for beat in self.beat_iterator(gongan):
                for position, measure in beat.measures.items():
                    for pass_ in self.pass_iterator(measure):
                        if (
                            position in self.run_settings.configdata.instruments.shorthand_notation
                            and sum(note.total_duration for note in pass_.notes) != beat.duration
                        ):
                            self._extend_measure(position=position, notes=pass_.notes, duration=beat.duration)

    def _record_to_metadata(self, record_list: list[MetaDataRecord]) -> list[MetaData]:
        """Converts a list of MetaDataRecord objects into a list of MetaData objects."""
        if not record_list:
            return list()
        metadata_list = []
        for record in record_list:
            metadata = MetaData(
                data={key: val for key, val in asdict(record).items() if not isinstance(val, _MISSING_TYPE)}
            )
            metadata_list.append(metadata)
        return metadata_list

    def _create_score_object_model(self) -> Score:
        """Creates an object model of the notation. The method aggregates each note and the corresponding diacritics
        into a single note object, which will simplify the generation of the MIDI file content.

        Args:
            datapath (str): path to the data folder
            infilename (str): name of the csv input file
            title (str): Title for the notation

        Returns:
            Score: A Score object model, not yet validated for inconsistencies.
        """
        beats: list[Beat] = []
        measures: list[Measure]
        for self.curr_gongan_id, gongan_info in self.notation.notation_dict.items():
            # Convert the metadata records to MetaData instances
            metadata_list = self._record_to_metadata(gongan_info.get(ParserTag.METADATA, []))
            if self.curr_gongan_id == DEFAULT:
                # Store global metadata and comment. Global gongan does not contain notation.
                self.score.global_metadata = metadata_list
                self.score.global_comments = gongan_info.get(ParserTag.COMMENTS, [])
            else:
                # Move metadata with scope == SCORE from the current gongan to the global_metadata list.
                gongan_info[ParserTag.METADATA] = [meta for meta in metadata_list if meta.data.scope == Scope.GONGAN]
                self.score.global_metadata.extend([meta for meta in metadata_list if meta.data.scope == Scope.SCORE])
            for self.curr_beat_id, measures in gongan_info[ParserTag.BEATS].items():
                # Generate measure content: convert NoteRecord objects to Note objects.
                for _, measure in measures.items():
                    for _, pass_ in measure.passes.items():
                        pass_.notes = self._convert_to_notes(
                            pass_.notes,
                            measure.position,
                            measure.all_positions,
                            metadata=gongan_info.get(ParserTag.METADATA, []) + self.score.global_metadata,
                        )
                # Create the beat and add it to the list of beats
                new_beat = Beat(
                    id=int(self.curr_beat_id),
                    gongan_id=int(self.curr_gongan_id),
                    measures=measures,
                    bpm_start={
                        DEFAULT: (bpm := self.score.gongans[-1].beats[-1].bpm_end[-1] if self.score.gongans else 0)
                    },
                    bpm_end={DEFAULT: bpm},
                    velocities_start={
                        DEFAULT: (
                            # velocity_start and velocity_end are dict[pass, dict[Position, Velocity]]
                            vel := (
                                self.score.gongans[-1].beats[-1].velocities_end[-1].copy()
                                if self.score.gongans
                                else {pos: self.default_velocity for pos in Position}
                            )
                        )
                    },
                    velocities_end={DEFAULT: vel.copy()},
                    # TODO Shouldn't we use mode instead of max? Makes a difference for error logging.
                    # Answer: not here, because at this stage, pokok positions with length 1 haven't been extended yet.
                    duration=max(
                        sum(note.total_duration for note in measure.passes[DEFAULT].notes)
                        for measure in measures.values()
                    ),
                )
                prev_beat = beats[-1] if beats else self.score.gongans[-1].beats[-1] if self.score.gongans else None
                # Update the `next` pointer of the previous beat.
                if prev_beat:
                    prev_beat.next = new_beat
                    new_beat.prev = prev_beat
                beats.append(new_beat)

            # Create a new gongan
            if beats:
                gongan = Gongan(
                    id=int(self.curr_gongan_id),
                    beats=beats,
                    beat_duration=mode(beat.duration for beat in beats),  # most occuring duration
                    metadata=gongan_info.get(ParserTag.METADATA, []) + self.score.global_metadata,
                    comments=gongan_info.get(ParserTag.COMMENTS, []),
                )
                self.score.gongans.append(gongan)
                beats = []

        # Add extension notes to pokok notation having only one note per beat
        self._complement_shorthand_pokok_measures()

        # Add blank measures for all other omitted instruments
        self._add_missing_measures(add_kempli=False)
        if self.run_settings.notation.beat_at_end:
            # This enables correct processing of metadata
            self._move_beat_to_start()
        for gongan in self.gongan_iterator(self.score):
            # TODO temporary fix. Create generators to iterate through gongans, beats and positions
            # These should update the curr counters.
            gongan.beat_duration = max(beat.duration for beat in gongan.beats)  # most occuring duration
            self._apply_metadata(gongan)
        # Process the sequences metadata
        self._process_sequences()
        # Add kempli beats
        self._add_missing_measures(add_kempli=True)

    @ParserModel.main
    def create_score(self):
        """This method does all the work.
        All settings are read from the (YAML) settings files.
        """

        self.loginfo("input file: %s", self.run_settings.notation.part.file)
        self._create_score_object_model()
        if self.has_errors:
            self.logerror("Program halted.")
            exit()

        return self.score


if __name__ == "__main__":
    pass
