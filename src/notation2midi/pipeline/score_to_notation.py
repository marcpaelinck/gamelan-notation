import csv
from os import path
from typing import override

import pandas as pd

from src.common.classes import Gongan, Note
from src.common.constants import ParserTag, Position
from src.notation2midi.classes import Agent
from src.notation2midi.execution import Score
from src.notation2midi.score2notationutils.utils import aggregate_positions, is_silent
from src.settings.classes import RunSettings
from src.settings.constants import InstrumentFields


class ScoreToNotationAgent(Agent):
    """Saves a corrected version of the notation input file"""

    AGENT_TYPE = Agent.AgentType.NOTATIONGENERATOR
    EXPECTED_INPUT_TYPES = (Agent.InputOutputType.RUNSETTINGS, Agent.InputOutputType.SCORE)
    RETURN_TYPE = None

    def __init__(self, run_settings: RunSettings, score: Score):
        super().__init__(run_settings)
        self.run_settings = run_settings
        self.score = score

    @override
    @classmethod
    def run_condition_satisfied(cls, run_settings: RunSettings):
        return run_settings.options.notation_to_midi.save_corrected_to_file

    def _notelist_to_string(self, notelist: list[Note]) -> str:  # here: gongan_to_records, test_utils
        return "".join((n.symbol for n in notelist if not n.autogenerated))

    def _gongan_to_records(self, gongan: Gongan) -> list[dict[Position | int, list[str]]]:
        """Converts a gongan to a dict containing the notation for the individual beats.

        Args:
            gongan (Gongan): gongan to convert
            skipemptylines (bool, optional): if true, positions without content (only rests) are skipped. Defaults to True.

        Returns:
            list[dict[Position | int, list[str]]]: _description_
        """
        pos_tags = aggregate_positions(gongan)

        result = (
            [{InstrumentFields.POSITION: ParserTag.COMMENTS, 1: comment} for comment in gongan.comments]
            + [
                {InstrumentFields.POSITION: ParserTag.METADATA, 1: metadata.data.model_dump_notation()}
                for metadata in gongan.metadata
            ]
            + [
                {
                    InstrumentFields.POSITION: pos_tags.get((position, passid), position)
                    + (f":{passid}" if passid > 0 else "")
                }
                | {beat.id: self._notelist_to_string(beat.get_notes(position)) for beat in gongan.beats}
                for (position, passid) in pos_tags.keys()
                if any(position in beat.measures for beat in gongan.beats)
                and not (is_silent(gongan=gongan, position=position, passid=passid))
            ]
            + [{InstrumentFields.POSITION: ""} | {beat.id: "" for beat in gongan.beats}]
        )

        return result

    @override
    def _main(self) -> None:  # score_validation
        """Converts a validated (and optionally corrected) score object back to the
        original notation format and saves it to file (.TSV).
        Args:
            score (Score): The score
        """
        score_dict = sum((self._gongan_to_records(gongan) for gongan in self.score.gongans), [])
        score_df = pd.DataFrame.from_records(score_dict)
        fpath, ext = path.splitext(self.score.settings.notation_filepath)
        filepath = fpath + "_CORRECTED" + ext
        score_df.to_csv(filepath, sep="\t", index=False, header=False, quoting=csv.QUOTE_NONE)
