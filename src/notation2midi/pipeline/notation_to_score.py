"""Creates a midi file based on a notation file.
See ./data/README.md for more information about notation files and ./data/notation/test
for an example of a notation file.
Main method: convert_notation_to_midi()
"""

from dataclasses import _MISSING_TYPE, asdict
from typing import override

from src.common.classes import Beat, Gongan, Measure, Notation, Score
from src.common.constants import (  # RuleType,
    DEFAULT,
    NotationDict,
    ParserTag,
    Position,
    VelocityInt,
)
from src.common.notes import NoteFactory

# from src.common.rules import RulesEngine
from src.notation2midi.classes import Agent, MetaDataRecord, NamedIntID
from src.notation2midi.metadata_classes import MetaData, MetaDataAdapter, Scope
from src.settings.classes import RunSettings

# pylint incorrectly reports an error when Pydantic fields are pre-assigned with the Field function
# pylint disable = no - member


class BeatID(NamedIntID):
    name = "BEAT"


class ScoreCreatorAgent(Agent):
    """Parser that converts the results of the notation parser into a Score object.
    This parser uses 'knowledge' about the instruments and idiom of the music to interpret the notation.
    It also processes the metadata.
    """

    LOGGING_MESSAGE = "CONVERTING NOTATION DICT TO SCORE"
    EXPECTED_INPUT_TYPES = (Agent.InputOutputType.RUNSETTINGS, Agent.InputOutputType.NOTATION)
    RETURN_TYPE = Agent.InputOutputType.GENERICSCORE

    notation: Notation = None
    score: Score = None

    POSITIONS_EXPAND_MEASURES = [
        Position.UGAL,
        Position.CALUNG,
        Position.JEGOGAN,
        Position.GONGS,
        Position.KEMPLI,
    ]

    default_velocity: VelocityInt

    def __init__(self, run_settings: RunSettings, notation: Notation):
        super().__init__(run_settings)
        self.notation = notation
        self.default_velocity = self.run_settings.midi.dynamics[self.run_settings.midi.default_dynamics]

        self.score = Score(
            title=self.run_settings.notationfile.title,
            settings=notation.settings,
            instrument_positions=self._get_all_positions(notation.notation_dict),
        )

    @override
    @classmethod
    def run_condition_satisfied(cls, run_settings: RunSettings):
        return True

    def _get_all_positions(self, notation_dict: NotationDict) -> set[Position]:
        all_instruments = [
            stave[ParserTag.POSITION]
            for gongan_id, gongan in notation_dict.items()
            if gongan_id > 0
            for stave in gongan[ParserTag.STAVES]
        ]
        return set(all_instruments)

    def _staves_to_beats(self, staves: list[dict]) -> list[dict]:
        """Tranforms the staves -> measures hierarchy of the notation_dict to beats -> measures.
            target structure is: gongan[beat_id][position][passes]
        Args:
            staves (list[dict]): staves belonging to the same gongan.

        Returns:
            list[dict]: the transposed structure
        """
        if not staves:
            return {}
        # There can be multiple staves with the same `position` value. In that case they will have different `pass`
        # values. The staves first need to be grouped by position. We create a position dict for this, will also
        # be used below to retrieve the correct ALL_POSITIONS value when a new Measure is created.
        position_dict = {stave[ParserTag.POSITION]: stave[ParserTag.ALL_POSITIONS] for stave in staves}
        staves_by_pos_pass = {
            position: {int(stave[ParserTag.PASS]): stave for stave in staves if stave[ParserTag.POSITION] == position}
            for position in position_dict.keys()
        }
        # count only non-empty beats
        beat_count = max(len([measure for measure in stave[ParserTag.MEASURES] if measure]) for stave in staves)
        beats = {
            BeatID(beat_seq + 1): {
                position: Measure(
                    position=position,
                    all_positions=position_dict[position],  # positions,
                    passes={
                        stave[ParserTag.PASS]: (
                            Measure.Pass(
                                seq=stave[ParserTag.PASS],
                                line=stave[ParserTag.LINE],
                                generic_notes=(
                                    stave[ParserTag.MEASURES][beat_seq]
                                    if beat_seq < len(stave[ParserTag.MEASURES])
                                    else []
                                ),
                                # ruletype=RuleType.UNISONO if len(stave[ParserTag.ALL_POSITIONS]) > 1 else None,
                                # autogenerated=False,
                            )
                        )
                        for pass_, stave in position_staves.items()
                    },
                )
                for position, position_staves in staves_by_pos_pass.items()
            }
            for beat_seq in range(beat_count)
        }

        return beats

    def _record_to_metadata(self, record_list: list[MetaDataRecord]) -> list[MetaData]:
        """Converts a list of MetaDataRecord objects into a list of MetaData objects."""
        if not record_list:
            return list()
        metadata_list = []
        for record in record_list:
            metadata = MetaDataAdapter.validate_python(
                {key: val for key, val in asdict(record).items() if not isinstance(val, _MISSING_TYPE)}
            )
            metadata_list.append(metadata)
        return metadata_list

    def _create_score_object_model(self) -> Score:
        """Creates an object model of the notation. The method aggregates each note and the corresponding diacritics
        into a single note object, which will simplify the generation of the MIDI file content.

        Args:
            datapath (str): path to the data folder
            infilename (str): name of the csv input file
            title (str): Title for the notation

        Returns:
            Score: A Score object model, not yet validated for inconsistencies.
        """

        beats: list[Beat] = []
        measures: dict[Position, Measure]
        for self.curr_gongan_id, gongan_info in self.notation.notation_dict.items():
            # Transpose the gongan from stave-oriented to beat-oriented
            gongan_info[ParserTag.BEATS] = self._staves_to_beats(gongan_info[ParserTag.STAVES])
            del gongan_info[ParserTag.STAVES]
            # Convert the metadata records to MetaData instances
            metadata_list = self._record_to_metadata(gongan_info.get(ParserTag.METADATA, []))
            if self.curr_gongan_id == DEFAULT:
                # Store global metadata and comment. Global gongan does not contain notation.
                self.score.global_metadata = metadata_list
                self.score.global_comments = gongan_info.get(ParserTag.COMMENTS, [])
            else:
                # Move metadata with scope == SCORE from the current gongan to the global_metadata list.
                gongan_info[ParserTag.METADATA] = [meta for meta in metadata_list if meta.scope == Scope.GONGAN]
                self.score.global_metadata.extend([meta for meta in metadata_list if meta.scope == Scope.SCORE])
            for self.curr_measure_id, measures in gongan_info[ParserTag.BEATS].items():
                # Generate measure content: convert NoteRecord objects to NoteSymbol objects.
                for _, measure in measures.items():
                    for _, pass_ in measure.passes.items():
                        self.curr_line_nr = pass_.line
                        pass_.generic_notes = [
                            NoteFactory.create_note_symbol(notechars) for notechars in pass_.generic_notes
                        ]
                        # pass_.notes = self._convert_to_notes(
                        #     pass_.notes,
                        #     measure.position,
                        #     measure.all_positions,
                        #     metadata=gongan_info.get(ParserTag.METADATA, []) + self.score.global_metadata,
                        # )
                # Create the beat and add it to the list of beats
                new_beat = Beat(
                    id=int(self.curr_measure_id),
                    gongan_id=int(self.curr_gongan_id),
                    measures=measures,
                )
                # for position, measure in new_beat.measures.items():  # pylint: disable=no-member
                #     for passnr in measure.passes.keys():
                #         self.update_grace_notes_octaves(beat=new_beat, position=position, passnr=passnr)
                prev_beat = beats[-1] if beats else self.score.gongans[-1].beats[-1] if self.score.gongans else None
                # Update the `next` pointer of the previous beat.
                if prev_beat:
                    prev_beat.next = new_beat
                    new_beat.prev = prev_beat
                beats.append(new_beat)
            # Create a new gongan
            if beats:
                gongan = Gongan(
                    id=int(self.curr_gongan_id),
                    beats=beats,
                    metadata=gongan_info.get(ParserTag.METADATA, []) + self.score.global_metadata,
                    comments=gongan_info.get(ParserTag.COMMENTS, []),
                )
                self.score.gongans.append(gongan)
                beats = []

    def _main(self):
        """This method does all the work.
        All settings are read from the (YAML) settings files.
        """

        self.loginfo("input file: %s", self.run_settings.notationfile.part.file)
        self._create_score_object_model()
        self.abort_if_errors()

        return self.score


if __name__ == "__main__":
    pass
