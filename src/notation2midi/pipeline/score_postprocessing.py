from typing import override

from pydantic import ValidationError

from src.common.classes import Beat, Gongan, Measure, Score
from src.common.constants import (
    DEFAULT,
    Duration,
    PassSequence,
    Pitch,
    Position,
    Stroke,
)
from src.common.notes import Note, NoteFactory
from src.notation2midi.classes import Agent
from src.notation2midi.metadata_classes import (
    AutoKempyungMeta,
    CopyMeta,
    DynamicsMeta,
    GonganMeta,
    GoToMeta,
    KempliMeta,
    LabelMeta,
    LoopMeta,
    MetaDataSwitch,
    MetaType,
    OctavateMeta,
    PartMeta,
    SequenceMeta,
    SuppressMeta,
    TempoMeta,
    ValidationMeta,
    ValidationProperty,
    WaitMeta,
)
from src.settings.classes import RunSettings


class ScorePostprocessAgent(Agent):
    """Fills empty and shorthand beats and applies metadata."""

    LOGGING_MESSAGE = "POSTPROCESSING SCORE"
    EXPECTED_INPUT_TYPES = (Agent.InputOutputType.PATTERNSCORE,)
    RETURN_TYPE = Agent.InputOutputType.COMPLETESCORE

    score: Score

    def __init__(self, pattern_score: Score):
        super().__init__(pattern_score.settings)
        self.score = pattern_score

    @override
    @classmethod
    def run_condition_satisfied(cls, run_settings: RunSettings):
        return True

    @classmethod
    def _kempli_beat(cls) -> Note:
        # a kempli beat is a muted stroke
        note = NoteFactory.create_note(
            position=Position.KEMPLI,
            pitch=Pitch.STRIKE,
            octave=None,
            effect=Stroke.MUTED,
            note_value=1.0,
            autogenerated=True,
        ).model_copy(update={"autogenerated": True})
        return note

    def _extend_measure(self, position: Position, notes: list[Note], duration: float):
        """Extend a measure with EXTENSION notes so that its length matches the required duration.

        Args:
            position (Position): instrument position
            notes (list[Note]): the measure content that should be extended
            duration (float): target duration
        """
        filler = NoteFactory.create_rest(position, Pitch.EXTENSION, note_value=1.0, autogenerated=True)
        measure_duration = sum(note.duration for note in notes)
        # Add rests of duration 1 to match the integer part of the beat's duration
        if int(duration - measure_duration) >= 1:
            try:
                fill_content = [filler.model_copy() for count in range(int(duration - len(notes)))]
                if self.score.settings.notation_settings.beat_at_end:
                    fill_content.extend(notes)
                    notes.clear()
                    notes.extend(fill_content)
                else:
                    notes.extend(fill_content)
                measure_duration = sum(note.duration for note in notes)
            except ValidationError:
                self.logerror(
                    "Could not add rest to beat %s-%s of %s", self.curr_gongan_id, self.curr_beat_id, position
                )
        # Add an extra rest for any fractional part of the beat's duration
        if measure_duration < duration:
            try:
                notes.append(
                    NoteFactory.create_rest(
                        position, Pitch.EXTENSION, note_value=duration - measure_duration, autogenerated=True
                    )
                )
            except ValidationError:
                self.logerror(
                    "Could not add rest to beat %s-%s of %s", self.curr_gongan_id, self.curr_beat_id, position
                )

    def _complement_shorthand_pokok_measures(self):
        """Adds EXTENSION notes to pokok measures that only contain one note (shorthand notation)"""

        # The measures are extended with rest notes using beat.max_duration as a reference.
        # A slight refinement might be to use the mode of the measures for which shorthand
        # notation is not allowed.
        for gongan in self.gongan_iterator(self.score):
            for beat in self.beat_iterator(gongan):
                for position, measure in beat.measures.items():
                    for pass_ in self.pass_iterator(measure):
                        if (
                            position in self.run_settings.configdata.instruments.shorthand_notation
                            and sum(note.duration for note in pass_.notes) != beat.max_duration
                        ):
                            self._extend_measure(position=position, notes=pass_.notes, duration=beat.max_duration)

    def _create_multiple_rests(self, position: Position, resttype: Pitch, duration: float) -> list[Note]:
        """Creates a measure with rests of the given type for the given duration.
        If the duration is non-integer, the stameasureve will also contain half and/or quarter rests.

        Args:
            resttype (Stroke): the type of rest (SILENCE or EXTENSION)
            duration (float): the duration, which can be non-integer.

        Returns:
            list[Note]: _description_
        """
        # TODO exception handling
        notes = []
        whole_rest: Note = NoteFactory.create_rest(position, resttype, note_value=1.0)
        for _ in range(int(duration)):
            notes.append(whole_rest.model_copy(update={"autogenerated": True}))

        # if duration is not integer, add the fractional part as an extra rest.
        if frac_duration := duration - int(duration):
            notes.append(whole_rest.model_copy(update={"note_value": frac_duration, "autogenerated": True}))

        return notes

    def _create_rest_measure(
        self, position: Position, resttype: Pitch, duration: float, pass_seq: PassSequence = DEFAULT
    ) -> Measure:
        notes = self._create_multiple_rests(position=position, resttype=resttype, duration=duration)
        return Measure.new(position=position, notes=notes, pass_seq=pass_seq, autogenerated=True)

    def _create_rest_measures(
        self,
        prev_beat: Beat,
        positions: list[Position],
        duration: Duration,
        force_silence: list[Position] = None,
        pass_seq: PassSequence = DEFAULT,
    ):
        silence = Pitch.SILENCE
        extension = Pitch.EXTENSION
        prev_pitches = {
            # We select the default pass because pass_seq might not be the corresponding sequence in prev_beat
            # as a consequence of the flow of the score that will be created in a later stage.
            pos: (prev_beat.get_notes(pos, DEFAULT)[-1].pitch if prev_beat else silence)
            for pos in positions
        }
        # Remark: the resttype is EXTENSION if the previous stroke is MUTED or ABBREVIATED.
        # This will avoid undesired muting when a GOTO points to this measure.
        resttypes = {
            pos: silence if prev_pitch is silence or pos in (force_silence or []) else extension
            for pos, prev_pitch in prev_pitches.items()
        }
        return {
            position: self._create_rest_measure(
                position=position, resttype=resttypes[position], duration=duration, pass_seq=pass_seq
            )
            for position in positions
        }

    def _create_missing_measures(
        self, beat: Beat, prevbeat: Beat, all_instruments: list[Position], force_silence=None
    ) -> dict[Position, Measure]:
        """Returns measures for missing positions, containing rests (silence) for the duration of the given beat.
        This ensures that positions that do not occur in all the gongans will remain in sync.
        We assume that the intended beat duration is equal to the duration of its longest measure.
        Measures in the same beat can have unequal lengths in the following situation:
        - Shorthand is being used (omitting rest notes is allowed for specific instruments).
        - An empty measure occurs.
        - A notation error occurs in a measure which either has too many or too few notes.
          This will be detected during the validation step.
        Args:
            beat (Beat): The beat that should be complemented.
            all_positions (set[Position]): List of all the positions that occur in the notation.
        Returns:
            dict[Position, Measure]: A dict with the generated measures.
        """

        # add rests to existing but empty measures
        for position, measure in beat.measures.items():
            for pass_ in measure.passes.values():
                if not pass_.notes:
                    resttype = (
                        Pitch.SILENCE
                        if (force_silence and position in force_silence)
                        or not prevbeat
                        or prevbeat.get_notes(position, DEFAULT)[-1].pitch is Pitch.SILENCE
                        else Pitch.EXTENSION
                    )
                    pass_.notes = self._create_multiple_rests(
                        position=position, resttype=resttype, duration=beat.max_duration
                    )
        # add measures for missing positions
        if missing_positions := (
            all_instruments
            - set(pos for pos in beat.measures.keys() if beat.measures[pos] and DEFAULT in beat.measures[pos].passes)
        ):
            measures = self._create_rest_measures(
                prev_beat=prevbeat, positions=missing_positions, duration=beat.max_duration, force_silence=force_silence
            )

            # Add a kempli beat, except if a metadata label indicates otherwise
            # or if the kempli part was already given in the original score
            if Position.KEMPLI in measures.keys():  # and has_kempli_beat(gongan):
                if beat.has_kempli_beat:
                    rests = self._create_multiple_rests(
                        Position.KEMPLI, resttype=Pitch.EXTENSION, duration=beat.max_duration - 1
                    )
                    measures[Position.KEMPLI] = Measure.new(
                        position=Position.KEMPLI, notes=[self._kempli_beat()] + rests, autogenerated=True
                    )
                else:
                    measures[Position.KEMPLI] = self._create_rest_measure(
                        Position.KEMPLI, Pitch.EXTENSION, beat.max_duration
                    )

            return measures
        else:
            return dict()

    def _add_missing_measures(self, add_kempli: bool = True):
        prev_beat = None
        for gongan in self.gongan_iterator(self.score):
            all_instruments = self.score.instrument_positions | (
                {Position.KEMPLI} if add_kempli else self.score.instrument_positions
            )
            gongan_missing_instr = [
                pos for pos in all_instruments if all(pos not in beat.measures for beat in gongan.beats)
            ]
            for beat in self.beat_iterator(gongan):
                # Not all positions occur in each gongan.
                # Therefore we need to add blank measure (all rests) for missing positions.
                # If an instrument is missing in the entire gongan, the last beat should consist
                # of silences (.) rather than note extensions (-). This avoids unexpected results when the next beat
                # is repeated and the kempli beat is at the end of the beat.
                force_silence = gongan_missing_instr if beat == gongan.beats[-1] else []
                missing_measures = self._create_missing_measures(
                    beat, prev_beat, all_instruments, force_silence=force_silence
                )
                beat.measures.update(missing_measures)
                # Update all positions of the score
                self.score.instrument_positions.update({pos for pos in missing_measures})
                prev_beat = beat

    def _has_kempli_beat(self, gongan: Gongan):
        return (
            not (kempli := gongan.metadata[MetaType.KEMPLI]) or kempli[0].status != MetaDataSwitch.OFF
        ) and gongan.gongantype not in self.run_settings.configdata.notation.gongantypes_without_kempli

    def _move_beat_to_start(self) -> None:
        # If the last gongan is regular (has a kempli beat), create an additional gongan with an empty beat
        last_gongan = self.score.gongans[-1]
        if self._has_kempli_beat(last_gongan):
            new_gongan = Gongan(id=last_gongan.id + 1, beats=[])
            self.score.gongans.append(new_gongan)
            last_beat = last_gongan.beats[-1]
            new_beat = Beat(
                id=1,
                gongan_id=int(last_gongan.id) + 1,
                prev=last_beat,
            )
            last_beat.next = new_beat
            for position in last_beat.measures.keys():
                # autogenerated=False because the content originates from the source.
                new_beat.measures[position] = Measure.new(position=position, notes=[], autogenerated=False)
            new_gongan.beats.append(new_beat)  # pylint: disable=no-member

        # Iterate through the beats starting from the end.
        # Move the end note of each instrument in the previous beat to the start of the current beat.
        # TODO WARNING: Only the default passes are shifted. Shifting other passes correctly would make this
        # method much more complicated and error prone due to possible unexpected effects of GOTO and LABEL
        # metadata. Therefore notation with kempli beat at the end should be avoided.
        beat = self.score.gongans[-1].beats[-1]
        while beat.prev:
            for position, measure in beat.prev.measures.items():
                if notes := measure.passes[DEFAULT].notes:  # only consider default pass.
                    # move notes with a total of 1 duration unit
                    notes_to_move = []
                    while notes and sum((note.duration for note in notes_to_move), 0) < 1:
                        notes_to_move.insert(0, notes.pop())
                    # Move orphaned grace note
                    if notes and notes[-1].effect is Stroke.GRACE_NOTE:
                        notes_to_move.insert(0, notes.pop())
                    if not position in beat.measures:
                        # autogenerated=False because the content originates from the source.
                        beat.measures[position] = Measure.new(position=position, notes=[], autogenerated=False)
                    beat.measures[position].passes[DEFAULT].notes[0:0] = notes_to_move  # insert at beginning
                    # Set autogenerated to False: the content is no longer (fully) autogenerated
                    # This is not very clear code. However notation with beat at the end is discouraged
                    # so don't want to spend too much time on this part.
                    beat.measures[position].passes[DEFAULT].autogenerated = False
            # update beat and gongan duration values
            # beat.duration = mode(
            #     sum(note.duration for note in measure.passes[DEFAULT].notes)
            #     for measure in list(beat.measures.values())
            # )
            beat = beat.prev

        # Add a rest at the beginning of the first beat
        for position, measure in self.score.gongans[0].beats[0].measures.items():
            measure.passes[DEFAULT].notes.insert(0, NoteFactory.create_rest(position, Pitch.SILENCE, note_value=1.0))

    def _apply_metadata(self, gongan: Gongan) -> None:
        """Processes the metadata of a gongan into the object model.

        Args:
            metadata (list[MetaData]): The metadata to process.
            gongan (Gongan): The gongan to which the metadata applies.
        """
        # Note that gongan.metadata also contains a copy of the score's global metadta. See notation_to_score.
        for meta in sorted(sum(gongan.metadata.values(), []), key=lambda x: x.processingorder):
            self.curr_line_nr = meta.line
            match meta:
                case AutoKempyungMeta():
                    # This metadata item is used in RulesEngine.cast_to_position to select the correct casting method.
                    continue
                case GonganMeta():
                    # TODO: how to safely synchronize all instruments starting from next regular gongan?
                    gongan.gongantype = meta.type
                    if gongan.gongantype in self.run_settings.configdata.notation.gongantypes_without_kempli:
                        for beat in gongan.beats:
                            beat.has_kempli_beat = False
                case KempliMeta():
                    # Suppress kempli.
                    # TODO status=ON will never be used because it is the default. So attribute status can be discarded.
                    # Unless a future version enables to switch kempli off until a Kempli ON tag is encountered.
                    if meta.status is MetaDataSwitch.OFF:
                        for beat in gongan.beats:
                            # Default is all beats
                            if beat.id in meta.beats or not meta.beats:
                                beat.has_kempli_beat = False
                case LabelMeta():
                    # Add the label to flowinfo
                    # TODO move this to Execution
                    gongan.haslabel = True
                    self.score.flowinfo.labels[meta.name] = gongan.beats[meta.beat_seq]
                case OctavateMeta():
                    positions = [pos for pos in Position if pos.instrumenttype is meta.instrument]
                    for beat in gongan.beats:
                        for position in positions:
                            if position in beat.measures.keys():
                                for pass_ in self.pass_iterator(beat.measures[position]):
                                    notes = pass_.notes
                                    for idx, note in enumerate(notes):
                                        if note.octave is not None:
                                            oct_note = NoteFactory.clone_note(note, octave=note.octave + meta.octaves)
                                            if oct_note:
                                                notes[idx] = oct_note
                                            else:
                                                self.logerror(
                                                    "could not octavate note %s%s with %s octave for %s."
                                                    % (note.pitch, note.octave, meta.octaves, position)
                                                )
                case PartMeta():
                    pass
                case SuppressMeta():
                    # Silences the given positions for the given beats and passes.
                    # This is done by adding pass(es) with SILENCE Notes.
                    for beat in gongan.beats:
                        # If no beats are given, default is all beats
                        if beat.id in meta.beats or not meta.beats:
                            for position in meta.positions:
                                if not position in beat.measures.keys():
                                    self.logwarning(
                                        f"Position {position} of {SuppressMeta.metatype} instruction not in gongan."
                                    )
                                    continue
                                line = beat.measures[position].passes[DEFAULT].line
                                for pass_seq in meta.passes:
                                    # Note that we are using the beat's mode duration here.
                                    # We assume that all beats have been complemented with rests if necessary.
                                    notes = self._create_multiple_rests(position, Pitch.EXTENSION, beat.duration)
                                    beat.measures[position].passes[pass_seq] = Measure.Pass(
                                        seq=pass_seq, line=line, notes=notes, autogenerated=True
                                    )
                case CopyMeta():
                    pass
                case ValidationMeta():
                    for beat in [b for b in gongan.beats if b.id in meta.beats] or gongan.beats:
                        beat.validation_ignore.extend(meta.ignore)
                case WaitMeta():
                    # Add a beat with silences at the end of the gongan.
                    # The beat's bpm is set to 60 for easy calculation.
                    lastbeat = gongan.beats[-1]
                    waitbeat = Beat(
                        id=lastbeat.id + 1,
                        gongan_id=gongan.id,
                        prev=lastbeat,
                        next=lastbeat.next,
                        has_kempli_beat=False,
                        validation_ignore=[ValidationProperty.BEAT_DURATION],
                    )
                    if lastbeat.next:
                        # modify the default next and prev pointes
                        lastbeat.next.prev = waitbeat
                        lastbeat.next = waitbeat
                        # move goto pointers to the end of the wait beat
                    duration = round(4 * meta.seconds)  # 4 notes per bpm unit and bpm=60 => 4 notes per second.
                    waitbeat.measures = self._create_rest_measures(
                        prev_beat=lastbeat, positions=list(lastbeat.measures.keys()), duration=duration
                    )
                    gongan.beats.append(waitbeat)
                case GoToMeta() | LabelMeta() | LoopMeta() | SequenceMeta() | TempoMeta() | DynamicsMeta():
                    # Processed by ExecutionCreatorAgent
                    # We mention these classes here to be sure that all metadata types are taken into account.
                    pass
                case _:
                    raise ValueError("Metadata type %s is not supported." % type(meta).__name__)

    @override
    def _main(self):
        # Check and correct beat lengths. These may have changed due to pattern generation.
        # self._recalculate_beat_durations()
        # Add extension notes to pokok notation having only one note per beat
        self._complement_shorthand_pokok_measures()
        # Add blank measures for all other omitted instruments
        self._add_missing_measures(add_kempli=False)
        if self.run_settings.notation_settings.beat_at_end:
            # This enables correct processing of metadata
            self._move_beat_to_start()
        for gongan in self.gongan_iterator(self.score):
            self._apply_metadata(gongan)
        # Add kempli beats
        self._add_missing_measures(add_kempli=True)
        # self._add_pattern_to_rests()
        return self.score
