"""Creates a midi file based on a notation file.
See ./data/README.md for more information about notation files and ./data/notation/test
for an example of a notation file.
Main method: convert_notation_to_midi()
"""

from dataclasses import _MISSING_TYPE, asdict
from statistics import mode
from typing import override

from pydantic import ValidationError

from src.common.classes import (
    Beat,
    Gongan,
    Instrument,
    Measure,
    Notation,
    Note,
    Score,
    Tone,
)
from src.common.constants import (
    DEFAULT,
    Duration,
    NotationDict,
    ParserTag,
    PassSequence,
    Pitch,
    Position,
    RuleValue,
    Stroke,
    VelocityInt,
)
from src.notation2midi.classes import Agent, MetaDataRecord, NoteRecord
from src.notation2midi.metadata_classes import (
    AutoKempyungMeta,
    DynamicsMeta,
    GonganMeta,
    GonganType,
    GoToMeta,
    KempliMeta,
    LabelMeta,
    LoopMeta,
    MetaData,
    MetaDataAdapter,
    MetaDataSwitch,
    OctavateMeta,
    PartMeta,
    Scope,
    SequenceMeta,
    SuppressMeta,
    TempoMeta,
    ValidationMeta,
    ValidationProperty,
    WaitMeta,
)
from src.notation2midi.special_notes_treatment import (
    generate_tremolo,
    update_grace_notes_octaves,
)
from src.settings.classes import RunSettings
from src.settings.constants import NoteFields

# pylint incorrectly reports an error when Pydantic fields are pre-assigned with the Field function
# pylint disable = no - member


class ScoreCreatorAgent(Agent):
    """Parser that converts the results of the notation parser into a Score object.
    This parser uses 'knowledge' about the instruments and idiom of the music to interpret the notation.
    It also processes the metadata.
    """

    AGENT_TYPE = Agent.AgentType.SCOREGENERATOR
    EXPECTED_INPUT_TYPES = (Agent.InputOutputType.RUNSETTINGS, Agent.InputOutputType.NOTATION)
    RETURN_TYPE = Agent.InputOutputType.SCORE

    notation: Notation = None
    score: Score = None

    POSITIONS_EXPAND_MEASURES = [
        Position.UGAL,
        Position.CALUNG,
        Position.JEGOGAN,
        Position.GONGS,
        Position.KEMPLI,
    ]

    default_velocity: VelocityInt

    def __init__(self, run_settings: RunSettings, notation: Notation):
        super().__init__(run_settings)
        self.notation = notation
        self.default_velocity = self.run_settings.midi.dynamics[self.run_settings.midi.default_dynamics]

        self.score = Score(
            title=self.run_settings.notationfile.title,
            settings=notation.settings,
            instrument_positions=self._get_all_positions(notation.notation_dict),
        )

    @override
    @classmethod
    def run_condition_satisfied(cls, run_settings: RunSettings):
        return run_settings.options.notation_to_midi

    def _get_all_positions(self, notation_dict: NotationDict) -> set[Position]:
        all_instruments = [
            p
            for gongan_id, gongan in notation_dict.items()
            if gongan_id > 0
            for beat_id, measures in gongan[ParserTag.BEATS].items()
            if isinstance(beat_id, int) and beat_id > 0
            for p in measures.keys()
        ]
        return set(all_instruments)

    def _has_kempli_beat(self, gongan: Gongan):
        return (
            not (kempli := gongan.get_metadata(KempliMeta)) or kempli.status != MetaDataSwitch.OFF
        ) and gongan.gongantype not in self.run_settings.configdata.notation.gongantypes_without_kempli

    def _move_beat_to_start(self) -> None:
        # If the last gongan is regular (has a kempli beat), create an additional gongan with an empty beat
        last_gongan = self.score.gongans[-1]
        if self._has_kempli_beat(last_gongan):
            new_gongan = Gongan(id=last_gongan.id + 1, beats=[], beat_duration=0)
            self.score.gongans.append(new_gongan)
            last_beat = last_gongan.beats[-1]
            new_beat = Beat(
                id=1,
                gongan_id=int(last_gongan.id) + 1,
                duration=0,
                prev=last_beat,
            )
            last_beat.next = new_beat
            for position in last_beat.measures.keys():
                # autogenerated=False because the content originates from the source.
                new_beat.measures[position] = Measure.new(position=position, notes=[], autogenerated=False)
            new_gongan.beats.append(new_beat)  # pylint: disable=no-member

        # Iterate through the beats starting from the end.
        # Move the end note of each instrument in the previous beat to the start of the current beat.
        # TODO WARNING: Only the default passes are shifted. Shifting other passes correctly would make this
        # method much more complicated and error prone due to possible unexpected effects of GOTO and LABEL
        # metadata. Therefore notation with kempli beat at the end should be avoided.
        beat = self.score.gongans[-1].beats[-1]
        while beat.prev:
            for position, measure in beat.prev.measures.items():
                if notes := measure.passes[DEFAULT].notes:  # only consider default pass.
                    # move notes with a total of 1 duration unit
                    notes_to_move = []
                    while notes and sum((note.total_duration for note in notes_to_move), 0) < 1:
                        notes_to_move.insert(0, notes.pop())
                    if not position in beat.measures:
                        # autogenerated=False because the content originates from the source.
                        beat.measures[position] = Measure.new(position=position, notes=[], autogenerated=False)
                    beat.measures[position].passes[DEFAULT].notes[0:0] = notes_to_move  # insert at beginning
                    # Set autogenerated to False: the content is no longer (fully) autogenerated
                    # This is not very clear code. However notation with beat at the end is discouraged
                    # so don't want to spend too much time on this part.
                    beat.measures[position].passes[DEFAULT].autogenerated = False
            # update beat and gongan duration values
            beat.duration = mode(
                sum(note.total_duration for note in measure.passes[DEFAULT].notes)
                for measure in list(beat.measures.values())
            )
            gongan = self.score.gongans[beat.gongan_seq]
            gongan.beat_duration = mode(beat.duration for beat in gongan.beats)
            beat = beat.prev

        # Add a rest at the beginning of the first beat
        for position, measure in self.score.gongans[0].beats[0].measures.items():
            measure.passes[DEFAULT].notes.insert(0, Note.get_whole_rest_note(position, Stroke.SILENCE))

    def _create_rest_notes(self, position: Position, resttype: Stroke, duration: float) -> list[Note]:
        """Creates a measure with rests of the given type for the given duration.
        If the duration is non-integer, the stameasureve will also contain half and/or quarter rests.

        Args:
            resttype (Stroke): the type of rest (SILENCE or EXTENSION)
            duration (float): the duration, which can be non-integer.

        Returns:
            list[Note]: _description_
        """
        # TODO exception handling
        notes = []
        whole_rest: Note = Note.get_whole_rest_note(position, resttype)
        for _ in range(int(duration)):
            notes.append(whole_rest.model_copy(update={"autogenerated": True}))

        # if duration is not integer, add the fractional part as an extra rest.
        if frac_duration := duration - int(duration):
            attribute = "duration" if whole_rest.duration > 0 else "rest_after"
            notes.append(whole_rest.model_copy(update={attribute: frac_duration, "autogenerated": True}))

        return notes

    def _create_rest_measure(
        self, position: Position, resttype: Stroke, duration: float, pass_seq: PassSequence = DEFAULT
    ) -> Measure:
        notes = self._create_rest_notes(position=position, resttype=resttype, duration=duration)
        return Measure.new(position=position, notes=notes, pass_seq=pass_seq, autogenerated=True)

    def _create_rest_measures(
        self,
        prev_beat: Beat,
        positions: list[Position],
        duration: Duration,
        force_silence: list[Position] = None,
        pass_seq: PassSequence = DEFAULT,
    ):
        silence = Stroke.SILENCE
        extension = Stroke.EXTENSION
        prevstrokes = {
            # We select the default pass because pass_seq might not be the corresponding sequence in prev_beat
            # as a consequence of the flow of the score that will be created in a later stage.
            pos: (prev_beat.get_notes(pos, DEFAULT)[-1].stroke if prev_beat else silence)
            for pos in positions
        }
        # Remark: the resttype is EXTENSION if the previous stroke is MUTED or ABBREVIATED.
        # This will avoid undesired muting when a GOTO points to this measure.
        resttypes = {
            pos: silence if prevstroke is silence or pos in (force_silence or []) else extension
            for pos, prevstroke in prevstrokes.items()
        }
        return {
            position: self._create_rest_measure(
                position=position, resttype=resttypes[position], duration=duration, pass_seq=pass_seq
            )
            for position in positions
        }

    def _note_from_rec(
        self,
        note_record: NoteRecord,
        position: Position,
        all_positions: list[Position],
        metadata: list[MetaData],
    ) -> Note:
        """Casts the given NoteRecord objevct to a Note object which is bound to a Position.
        If multiple positions share the same notation this method applies rules
        (e.g. octavation or kempyung) to cast the NoteRecord to the correct Note for the given position.
        Args:
            symbol (str): notation characters.
            position (Position): position to match.
            unisono_positions (list[Position]): positions that share the same notation.
        Returns:
            Note: _description_
        """
        if len(all_positions) == 1:
            # Notation for single position
            if position not in all_positions:
                raise ValueError(f"{position} not in list {all_positions}")
            note = Note.get_note(
                position,
                pitch=note_record.pitch,
                octave=note_record.octave,
                stroke=note_record.stroke,
                duration=note_record.duration,
                rest_after=note_record.rest_after,
            )
            if not note:
                # Most common error is wrong octave. Find similar symbols with the correct octave.
                any_oct_symbol = note_record.symbol + ",<"
                alternatives = [
                    n.symbol
                    for n in Note.VALIDNOTES
                    if n.position is position and all(char in any_oct_symbol for char in n.symbol)
                ]
                msg1 = "Invalid note '%s' for %s." % (note_record.symbol, position)
                msg2 = " Did you mean '%s'?" % ("or '".join(alternatives)) if alternatives else ""
                raise ValueError(msg1 + msg2)
            return note

        # The notation is for multiple positions. Determine pitch and octave using the 'unisono rules'.

        # Create a Tone object from the the symbol by finding any matching note (disregarding the position)
        reference_tone = Tone(note_record.pitch, note_record.octave)
        tone = Instrument.cast_to_position(
            tone=reference_tone, position=position, all_positions=set(all_positions), metadata=metadata
        )

        # Return the matching note within the position's range
        if tone:
            note = Note.get_note(
                position=position,
                pitch=tone.pitch,
                octave=tone.octave,
                stroke=note_record.stroke,
                duration=note_record.duration,
                rest_after=note_record.rest_after,
            )
            return note.model_copy_x(transformation=tone.transformation)
        else:
            # return silence
            note = Note.get_note(
                position=position,
                pitch=Pitch.NONE,
                octave=None,
                stroke=Stroke.SILENCE,
                duration=0,
                rest_after=note_record.duration + note_record.rest_after,
            )
            return note
            # raise ValueError("Could not find an equivalent for %s for %s}" % (note_record.symbol, position))

    def _convert_to_notes(
        self,
        noterecord_list: list[NoteRecord],
        position: Position,
        all_positions: list[Position],
        metadata: list[MetaData],
    ) -> list[Note]:
        """Converts the generic NoteRecord objects to position bound Note objects.
            Applies rules to transform the note to the correct value for the given position (e.g. kempyung, octavation).
            Updates the octave of grace notes.
            Converts tremolo notes to a pattern of Note objects.

           If the stave stands for multiple reyong positions, the notation is transformed to match
           each position separately. There are two possible cases:
            - REYONG_1 and REYONG_3 are combined: the notation is expected to represent the REYONG_1 part
              and the score is octavated for the REYONG_3 position.
            - REYONG_2 and REYONG_4: similar case. The notation should represent the REYONG_2 part.
            - All reyong positions: the notation is expected to represent the REYONG_1 part.
              In this case the kempyung equivalent of the notation will be determined for REYONG_2
              and REYONG_4 within their respective range.

        Args:
            stave (str): one stave of notation
            position (Position):
            multiple_positions (list[Position]): List of all positions for this stave.

        Returns: str | None: _description_
        """
        notes = []  # will contain the Note objects
        for note_rec in noterecord_list:
            # try parsing the next note
            # next_note = Note.parse_next_note(note_chars, position)
            try:
                next_note = self._note_from_rec(note_rec, position, all_positions, metadata=metadata)
            except ValueError as e:
                self.logerror(str(e))
            if not next_note:
                self.logerror(f"Could not cast {note_rec[NoteFields.SYMBOL]} to {position.value}")
            else:
                notes.append(next_note)
        try:
            notes = update_grace_notes_octaves(measure=notes)
            notes = generate_tremolo(measure=notes, midi_settings=self.run_settings.midi, errorlogger=self.logerror)
        except ValueError as e:
            self.logerror(str(e))
        return notes

    def _apply_metadata(self, gongan: Gongan) -> None:
        """Processes the metadata of a gongan into the object model.

        Args:
            metadata (list[MetaData]): The metadata to process.
            gongan (Gongan): The gongan to which the metadata applies.
        """
        metadata = gongan.metadata.copy() + self.score.global_metadata
        for meta in sorted(metadata, key=lambda x: x.processingorder):
            self.curr_line_nr = meta.line
            match meta:
                case AutoKempyungMeta():
                    # This metadata item is used in Instrument.cast_to_position to select the correct casting method.
                    continue
                case GonganMeta():
                    # TODO: how to safely synchronize all instruments starting from next regular gongan?
                    gongan.gongantype = meta.type
                    if gongan.gongantype in self.run_settings.configdata.notation.gongantypes_without_kempli:
                        for beat in gongan.beats:
                            beat.has_kempli_beat = False
                case KempliMeta():
                    # Suppress kempli.
                    # TODO status=ON will never be used because it is the default. So attribute status can be discarded.
                    # Unless a future version enables to switch kempli off until a Kempli ON tag is encountered.
                    if meta.status is MetaDataSwitch.OFF:
                        for beat in gongan.beats:
                            # Default is all beats
                            if beat.id in meta.beats or not meta.beats:
                                beat.has_kempli_beat = False
                case OctavateMeta():
                    positions = [pos for pos in Position if pos.instrumenttype is meta.instrument]
                    for beat in gongan.beats:
                        for position in positions:
                            if position in beat.measures.keys():
                                for pass_ in self.pass_iterator(beat.measures[position]):
                                    notes = pass_.notes
                                    for idx, note in enumerate(notes):
                                        if note.octave is not None:
                                            oct_note = Note.get_note(
                                                note.position,
                                                note.pitch,
                                                note.octave + meta.octaves,
                                                note.stroke,
                                                note.duration,
                                                note.rest_after,
                                            )
                                            if oct_note:
                                                oct_note = oct_note.model_copy_x(transformation=RuleValue.SAME_PITCH)
                                                notes[idx] = oct_note
                                            else:
                                                self.logerror(
                                                    "could not octavate note %s%s with %s octave for %s."
                                                    % (note.pitch, note.octave, meta.octaves, position)
                                                )
                case PartMeta():
                    pass
                case SuppressMeta():
                    # Silences the given positions for the given beats and passes.
                    # This is done by adding pass(es) with SILENCE Notes.
                    for beat in gongan.beats:
                        # If no beats are given, default is all beats
                        if beat.id in meta.beats or not meta.beats:
                            for position in meta.positions:
                                if not position in beat.measures.keys():
                                    self.logwarning(
                                        f"Position {position} of {SuppressMeta.metatype} instruction not in gongan."
                                    )
                                    continue
                                line = beat.measures[position].passes[DEFAULT].line
                                for pass_seq in meta.passes:
                                    notes = self._create_rest_notes(position, Stroke.EXTENSION, beat.duration)
                                    beat.measures[position].passes[pass_seq] = Measure.Pass(
                                        seq=pass_seq, line=line, notes=notes, autogenerated=True
                                    )
                case ValidationMeta():
                    for beat in [b for b in gongan.beats if b.id in meta.beats] or gongan.beats:
                        beat.validation_ignore.extend(meta.ignore)
                case WaitMeta():
                    # Add a beat with silences at the end of the gongan.
                    # The beat's bpm is set to 60 for easy calculation.
                    lastbeat = gongan.beats[-1]
                    duration = round(4 * meta.seconds)  # 4 notes per bpm unit and bpm=60 => 4 notes per second.
                    waitbeat = Beat(
                        id=lastbeat.id + 1,
                        gongan_id=gongan.id,
                        duration=duration,
                        prev=lastbeat,
                        next=lastbeat.next,
                        has_kempli_beat=False,
                        validation_ignore=[ValidationProperty.BEAT_DURATION],
                    )
                    if lastbeat.next:
                        # modify the default next and prev pointes
                        lastbeat.next.prev = waitbeat
                        lastbeat.next = waitbeat
                        # move goto pointers to the end of the wait beat
                    waitbeat.measures = self._create_rest_measures(
                        prev_beat=lastbeat, positions=list(lastbeat.measures.keys()), duration=duration
                    )
                    gongan.beats.append(waitbeat)
                case GoToMeta() | LabelMeta() | LoopMeta() | SequenceMeta() | TempoMeta() | DynamicsMeta():
                    # Processed by ExecutionCreatorAgent
                    # We mention these classes here to be sure that all metadata types are taken into account.
                    pass
                case _:
                    raise ValueError("Metadata type %s is not supported." % type(meta).__name__)

    @classmethod
    def _kempli_beat(cls) -> Note:
        # a kempli beat is a muted stroke
        return Note.get_note(
            Position.KEMPLI,
            pitch=Pitch.STRIKE,
            octave=None,
            stroke=Stroke.MUTED,
            duration=1,
            rest_after=0,
        ).model_copy(update={"autogenerated": True})

    def _create_missing_measures(
        self, beat: Beat, prevbeat: Beat, all_instruments: list[Position], force_silence=None
    ) -> dict[Position, Measure]:
        """Returns measures for missing positions, containing rests (silence) for the duration of the given beat.
        This ensures that positions that do not occur in all the gongans will remain in sync.
        Args:
            beat (Beat): The beat that should be complemented.
            all_positions (set[Position]): List of all the positions that occur in the notation.
        Returns:
            dict[Position, Measure]: A dict with the generated measures.
        """

        # add rests to existing but empty measures
        for position, measure in beat.measures.items():
            for pass_ in measure.passes.values():
                if not pass_.notes:
                    resttype = (
                        Stroke.SILENCE
                        if (force_silence and position in force_silence)
                        or prevbeat.get_notes(position, DEFAULT)[-1].stroke is Stroke.SILENCE
                        else Stroke.EXTENSION
                    )
                    pass_.notes = self._create_rest_notes(position=position, resttype=resttype, duration=beat.duration)
        # add measures for missing positions
        if missing_positions := (all_instruments - set(pos for pos in beat.measures.keys() if beat.measures[pos])):
            measures = self._create_rest_measures(
                prev_beat=prevbeat, positions=missing_positions, duration=beat.duration, force_silence=force_silence
            )

            # Add a kempli beat, except if a metadata label indicates otherwise
            # or if the kempli part was already given in the original score
            if Position.KEMPLI in measures.keys():  # and has_kempli_beat(gongan):
                if beat.has_kempli_beat:
                    rests = self._create_rest_notes(Position.KEMPLI, Stroke.EXTENSION, beat.duration - 1)
                    measures[Position.KEMPLI] = Measure.new(
                        position=Position.KEMPLI, notes=[self._kempli_beat()] + rests, autogenerated=True
                    )
                else:
                    measures[Position.KEMPLI] = self._create_rest_measure(
                        Position.KEMPLI, Stroke.EXTENSION, beat.duration
                    )

            return measures
        else:
            return dict()

    def _add_missing_measures(self, add_kempli: bool = True):
        prev_beat = None
        for gongan in self.gongan_iterator(self.score):
            all_instruments = self.score.instrument_positions | (
                {Position.KEMPLI} if add_kempli else self.score.instrument_positions
            )
            gongan_missing_instr = [
                pos for pos in all_instruments if all(pos not in beat.measures for beat in gongan.beats)
            ]
            for beat in self.beat_iterator(gongan):
                # Not all positions occur in each gongan.
                # Therefore we need to add blank measure (all rests) for missing positions.
                # If an instrument is missing in the entire gongan, the last beat should consist
                # of silences (.) rather than note extensions (-). This avoids unexpected results when the next beat
                # is repeated and the kempli beat is at the end of the beat.
                force_silence = gongan_missing_instr if beat == gongan.beats[-1] else []
                missing_measures = self._create_missing_measures(
                    beat, prev_beat, all_instruments, force_silence=force_silence
                )
                beat.measures.update(missing_measures)
                # Update all positions of the score
                self.score.instrument_positions.update({pos for pos in missing_measures})
                prev_beat = beat

    def _extend_measure(self, position: Position, notes: list[Note], duration: float):
        """Extend a measure with EXTENSION notes so that its length matches the required duration.

        Args:
            position (Position): instrument position
            notes (list[Note]): the measure content that should be extended
            duration (float): target duration
        """
        filler = Note.get_whole_rest_note(position, Stroke.EXTENSION)
        measure_duration = sum(note.total_duration for note in notes)
        # Add rests of duration 1 to match the integer part of the beat's duration
        if int(duration - measure_duration) >= 1:
            try:
                fill_content = [
                    filler.model_copy(update={"autogenerated": True}) for count in range(int(duration - len(notes)))
                ]
                if self.score.settings.notationfile.beat_at_end:
                    fill_content.extend(notes)
                    notes.clear()
                    notes.extend(fill_content)
                else:
                    notes.extend(fill_content)
                measure_duration = sum(note.total_duration for note in notes)
            except ValidationError:
                self.logerror(
                    "Could not add rest to beat %s-%s of %s", self.curr_gongan_id, self.curr_beat_id, position
                )
        # Add an extra rest for any fractional part of the beat's duration
        if measure_duration < duration:
            attr = "duration" if filler.stroke == Stroke.EXTENSION else "rest_after"
            try:
                notes.append(filler.model_copy(update={attr: duration - measure_duration, "autogenerated": True}))
            except ValidationError:
                self.logerror(
                    "Could not add rest to beat %s-%s of %s", self.curr_gongan_id, self.curr_beat_id, position
                )

    def _complement_shorthand_pokok_measures(self):
        """Adds EXTENSION notes to pokok measures that only contain one note (shorthand notation)"""

        for gongan in self.gongan_iterator(self.score):
            for beat in self.beat_iterator(gongan):
                for position, measure in beat.measures.items():
                    for pass_ in self.pass_iterator(measure):
                        if (
                            position in self.run_settings.configdata.instruments.shorthand_notation
                            and sum(note.total_duration for note in pass_.notes) != beat.duration
                        ):
                            self._extend_measure(position=position, notes=pass_.notes, duration=beat.duration)

    def _record_to_metadata(self, record_list: list[MetaDataRecord]) -> list[MetaData]:
        """Converts a list of MetaDataRecord objects into a list of MetaData objects."""
        if not record_list:
            return list()
        metadata_list = []
        for record in record_list:
            metadata = MetaDataAdapter.validate_python(
                {key: val for key, val in asdict(record).items() if not isinstance(val, _MISSING_TYPE)}
            )
            metadata_list.append(metadata)
        return metadata_list

    def _create_score_object_model(self) -> Score:
        """Creates an object model of the notation. The method aggregates each note and the corresponding diacritics
        into a single note object, which will simplify the generation of the MIDI file content.

        Args:
            datapath (str): path to the data folder
            infilename (str): name of the csv input file
            title (str): Title for the notation

        Returns:
            Score: A Score object model, not yet validated for inconsistencies.
        """
        beats: list[Beat] = []
        measures: dict[Position, Measure]
        for self.curr_gongan_id, gongan_info in self.notation.notation_dict.items():
            # Convert the metadata records to MetaData instances
            metadata_list = self._record_to_metadata(gongan_info.get(ParserTag.METADATA, []))
            if self.curr_gongan_id == DEFAULT:
                # Store global metadata and comment. Global gongan does not contain notation.
                self.score.global_metadata = metadata_list
                self.score.global_comments = gongan_info.get(ParserTag.COMMENTS, [])
            else:
                # Move metadata with scope == SCORE from the current gongan to the global_metadata list.
                gongan_info[ParserTag.METADATA] = [meta for meta in metadata_list if meta.scope == Scope.GONGAN]
                self.score.global_metadata.extend([meta for meta in metadata_list if meta.scope == Scope.SCORE])
            for self.curr_beat_id, measures in gongan_info[ParserTag.BEATS].items():
                # Generate measure content: convert NoteRecord objects to Note objects.
                for _, measure in measures.items():
                    for _, pass_ in measure.passes.items():
                        self.curr_line_nr = pass_.line
                        pass_.notes = self._convert_to_notes(
                            pass_.notes,
                            measure.position,
                            measure.all_positions,
                            metadata=gongan_info.get(ParserTag.METADATA, []) + self.score.global_metadata,
                        )
                # Create the beat and add it to the list of beats
                new_beat = Beat(
                    id=int(self.curr_beat_id),
                    gongan_id=int(self.curr_gongan_id),
                    measures=measures,
                    duration=max(
                        sum(note.total_duration for note in measure.passes[DEFAULT].notes)
                        for measure in measures.values()
                    ),
                    # TODO Shouldn't we use mode instead of max? Makes a difference for error logging.
                    # Answer: not here, because at this stage, pokok positions with length 1 haven't been extended yet.
                )
                prev_beat = beats[-1] if beats else self.score.gongans[-1].beats[-1] if self.score.gongans else None
                # Update the `next` pointer of the previous beat.
                if prev_beat:
                    prev_beat.next = new_beat
                    new_beat.prev = prev_beat
                beats.append(new_beat)
            # Create a new gongan
            if beats:
                gongan = Gongan(
                    id=int(self.curr_gongan_id),
                    beats=beats,
                    beat_duration=mode(beat.duration for beat in beats),  # most occuring duration
                    metadata=gongan_info.get(ParserTag.METADATA, []) + self.score.global_metadata,
                    comments=gongan_info.get(ParserTag.COMMENTS, []),
                )
                self.score.gongans.append(gongan)
                beats = []

        # Add extension notes to pokok notation having only one note per beat
        self._complement_shorthand_pokok_measures()

        # Add blank measures for all other omitted instruments
        self._add_missing_measures(add_kempli=False)
        if self.run_settings.notationfile.beat_at_end:
            # This enables correct processing of metadata
            self._move_beat_to_start()
        for gongan in self.gongan_iterator(self.score):
            # TODO temporary fix. Create generators to iterate through gongans, beats and positions
            # These should update the curr counters.
            gongan.beat_duration = max(beat.duration for beat in gongan.beats)  # most occuring duration
            self._apply_metadata(gongan)
        # Process the sequences metadata
        # self._process_sequences()
        # Add kempli beats
        self._add_missing_measures(add_kempli=True)

    def _main(self):
        """This method does all the work.
        All settings are read from the (YAML) settings files.
        """

        self.loginfo("input file: %s", self.run_settings.notationfile.part.file)
        self._create_score_object_model()
        if self.has_errors:
            self.logerror("Program halted.")
            exit()

        return self.score


if __name__ == "__main__":
    pass
