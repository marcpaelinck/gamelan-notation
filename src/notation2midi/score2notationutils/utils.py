"""Utility functions for the conversion of a Score object to a PDF notation file."""

import html
import re
from functools import partial

from src.common.classes import Gongan, Instrument, Note
from src.common.constants import Pitch, Position, Stroke
from src.notation2midi.metadata_classes import GonganType, MetaDataSwitch
from src.notation2midi.pipeline.notation_parser_tatsu import PassID


def measure_to_str_rml_safe(
    notes: list[Note], omit_octave_diacritics: list[Position], octave_diacritics: list[str]
) -> str:
    """Converts the note objects to notation symbols.
    Replaces characters that are incompatible with RML content to compatible strings.
    RML is an XML-style markup language used by ReportLab.
    See https://docs.reportlab.com/rmlfornewbies/
    Args:
        notes (list[Note]): Content that should be converted.
        omit_octave_diacritics (list[Position]): positions for which to omit octave indicator
         octave_diacritics (list[str]): list of octave diacritics
    Returns:
        str: HTML/XML compatible representation of the notation.
    """

    def format_symbol(note: Note):
        """Returns the formatted note symbol"""
        if note.stroke == Stroke.GRACE_NOTE:
            # Remove any stroke modifier character
            return note.symbol[0]
        if note.position in omit_octave_diacritics:
            # Remove octave modifier character for given positions
            return re.sub(f"[{"".join(octave_diacritics)}]", "", note.symbol)
        return note.symbol

    if not notes:
        return ""
    notechars = html.escape("".join(format_symbol(note) for note in notes))
    return notechars


def clean_staves(gongan: Gongan) -> dict[tuple[Position, PassID], list[list[Note]]]:
    """Converts a gongan into a dict. Removes autogenerated notes (e.g. created to emulate
    tremolo stroke or WAIT metadata).
    Also removes staves that are completely empty after removing autogenerated notes.
    Args:
        gongan (Gongan): The congan that should be 'cleaned'.
    Returns:
        dict[(Position, PassID), list[list[Note]]]: The gongan in tabular form.
    """
    if not gongan.beats:
        return dict()
    # create a dict (Position, PassID) -> list[list[Note]]
    # Make a list of beats containing only autogenerated notes. These will be skipped.
    skip_beats = set(
        beat.id
        for beat in gongan.beats
        if all(
            note.autogenerated
            for measure in beat.measures.values()
            for pass_ in measure.passes.values()
            for note in pass_.notes
        )
    )
    staves = {
        (position, passid): (
            [
                [note for note in beat.measures[position].passes[passid].notes if not note.autogenerated]
                for beat in gongan.beats
                if beat.id not in skip_beats
                if position in beat.measures
                if passid in beat.measures[position].passes
            ]
        )
        for position, measure in gongan.beats[0].measures.items()
        for passid in measure.passes.keys()
    }

    # Remove staves that are completely empty
    staves = {key: measures for key, measures in staves.items() if any(measure for measure in measures)}
    return staves


def to_aggregated_tags(positions: list[Position]) -> list[str]:
    """Returns a lowercase value of the instrument names. This function is used
       to format the values of the `positions` parameter of metadata items.
    Args:
        positions (list[Position]):
    Returns:
        list[str]: list of lowercase values for the instrument names.
    """
    tags = set(pos.lower() for pos in positions)
    pemade = {Position.PEMADE_POLOS.lower(), Position.PEMADE_SANGSIH.lower()}
    kantilan = {Position.KANTILAN_POLOS.lower(), Position.KANTILAN_SANGSIH.lower()}
    gangsa = {"pemade", "kantilan"}
    reyong13 = {Position.REYONG_1.lower(), Position.REYONG_2.lower()}
    reyong24 = {Position.REYONG_3.lower(), Position.REYONG_4.lower()}
    reyong = {"reyong1+3", "reyong2+4"}
    # Aggregate pemade and kantilan if both appear in the position list.
    if pemade.issubset(tags):
        tags = tags.difference(pemade).union({"pemade"})
    if kantilan.issubset(tags):
        tags = tags.difference(kantilan).union({"kantilan"})
    if gangsa.issubset(tags):
        tags = tags.difference(gangsa).union({"gangsa"})
    if reyong13.issubset(tags):
        tags = tags.difference(reyong13).union({"reyong1+3"})
    if reyong24.issubset(tags):
        tags = tags.difference(reyong24).union({"reyong2+4"})
    if reyong.issubset(tags):
        tags = tags.difference(reyong).union({"reyong"})

    return tags


def has_kempli_beat(gongan: Gongan) -> bool:
    """Determines if the gongan has a kempli beat.
    Args:
        gongan (Gongan):
    Returns:
        bool: True if there is a kempli beat, otherwise False
    """
    return not any(
        (meta.metatype == "KEMPLI" and meta.status is MetaDataSwitch.OFF)
        or (meta.metatype == "GONGAN" and meta.type is not GonganType.REGULAR)
        for meta in gongan.metadata
    )


def is_silent(gongan: Gongan, position: Position, passid: PassID) -> bool:  # here: gongan_to_records
    """True if all the measures for the position/passid combination contain only notes with
    EXTENSION and/or SILENCE Stroke values.
    """
    no_occurrence = sum((beat.get_notes(position, passid, none=[]) for beat in gongan.beats), []) == []
    all_rests = all(
        note.pitch == Pitch.NONE for beat in gongan.beats for note in beat.get_notes(position, passid, none=[])
    )
    return no_occurrence or all_rests


def same(note1: Note, note2: Note) -> bool:
    """Compares two notes.
    Args:
        notes1 (list[Note]): first note to compare.
        notes2 (list[Note]): second note to compare.
    Returns:
        bool: True if both notes have the same pitch, octave, stroke, duration, rest after and velocity.
    """
    return (
        note1.pitch == note2.pitch
        and note1.octave == note2.octave
        and note1.stroke == note2.stroke
        and note1.duration == note2.duration
        and note1.rest_after == note2.rest_after
        and note1.velocity == note2.velocity
    )


def equivalent(note1: Note, note2: Note, positions: list[Position], metadata) -> bool:
    """Determines if two notes correspond with each other by applying if instrument transformation rules
       to cast the notes to each other's position.
       Returns true if the notes are equivalent, e.g. if a sangsih note is the kempyung of a polos note.
    Args:
        notes1 (list[Note]): first note to compare.
        notes2 (list[Note]): second note to compare.
        positions (list[Position]): positions that should be involved in the instrument rules.
    Returns:
        bool: True if the notes are equivalent
    """
    if note2.is_melodic():
        tone2cast = Instrument.cast_to_position(
            note2.to_tone(), position=note1.position, all_positions=positions, metadata=metadata
        )
        if not tone2cast:
            return False
        try:
            note2cast = note2.model_copy_x(pitch=tone2cast.pitch, octave=tone2cast.octave, position=note1.position)
        except ValueError:
            return False
    else:
        try:
            note2cast = note2.model_copy_x(position=note1.position)
        except ValueError:
            return False
    return same(note1, note2cast)


def compare(notes1: list[Note], notes2: list[Note], comparator: callable) -> bool:
    """Compares two lists of notes by using the given comparator function.
    Args:
        notes1 (list[Note]): first list of notes.
        notes2 (list[Note]): second list of notes.
        comparator (callable): function that takes two Note objects as arguments and returns True if both notes match.
    Returns:
        bool: True if all the notes in both listss give a match.
    """
    if len(notes1) != len(notes2):
        return False
    return all(comparator(note1, note2) for note1, note2 in zip(notes1, notes2))


def aggregate_positions(gongan: Gongan) -> dict[tuple[Position, PassID], str]:
    """Returns a dict that maps positions to labels ('tags'). Groups certain positions with identical staves:
       GANGSA_P, GANGSA_S, GANGSA, REYONG_13, REYONG_24 and REYONG.
    Args:
        gongan (Gongan): gongan to convert

    Returns:
        dict[Position, list[str]]: The 'position-to-tag' dict.
    """
    # pos_pass_tags maps (position, pas) pairs to short tag values. It contains only the non-silent positions
    # that occur in the gongan. The pass number is appended to the tags of non-default passes that differ
    # from the default stave. The KEMPLI is omitted.
    pos_pass_combis = [
        (position, PassID(passid))
        for position, measure in gongan.beats[0].measures.items()
        if position != Position.KEMPLI
        for passid, pass_ in measure.passes.items()
        if not pass_.autogenerated
    ]
    pos_pass_tags = {
        (position, passid): position.shortcode + (f":{int(passid)}" if passid > 0 else "")
        for position, passid in sorted(
            list(pos_pass_combis), key=lambda x: x[0].sequence + (x[1] / 100 if x[1] > 0 else -x[1] / 10)
        )
    }

    # Remove empty staves
    for position, passid in list(pos_pass_tags.keys()):
        if is_silent(gongan, position, passid):
            del pos_pass_tags[position, passid]

    def try_to_aggregate_pos(positions: list[Position], passid: PassID, aggregate_tag: str) -> bool:
        """Determines if the notation is identical for all of the given positions for the given pass.
        In that case, updates the pos_pass_tags dict.
        Args:
            positions (list[Position]): positions for which to aggregate the notation.
            passid (PassID): the pass for which to aggregate the positions.
            aggregate_tag (str): the instrument tag that should be used for the aggregated notation.
        Returns:
            bool: True if aggregation is possible.
        """
        # Check if all positions occur in the gongan after removing empty staves
        if not all((pos, passid) in pos_pass_tags.keys() for pos in positions):
            return False
        # Determine if all measures of the given positions are equivalent
        comparator = partial(equivalent, positions=positions, metadata=gongan.metadata)
        all_positions_have_same_notation = all(
            all(
                compare(beat.get_notes(pos, passid), beat.get_notes(positions[0], passid), comparator)
                for beat in gongan.beats
            )
            for pos in positions
        )
        if all_positions_have_same_notation:
            # Set the tag of the first position as the aggregate tag.
            pos_pass_tags[positions[0], passid] = aggregate_tag + (f":{int(passid)}" if passid > 0 else "")
            # Delete all other positions in the pos_tags dict.
            keys_to_delete = [(pos, pid) for pos, pid in pos_pass_tags.keys() if pos in positions[1:] and pid == passid]
            for pos, pid in keys_to_delete:
                del pos_pass_tags[pos, passid]
            return True
        return False

    def aggregate_passes() -> None:
        """Determines if the notation is identical for consecutive passes of the same position.
        In that case groups the passes and updates the pos_pass_tags dict.
        """
        # Create a dict {pos -> [passes]} for positions with multiple passes (excluding the DEFAULT pass).
        pos_pass_dict = {
            pos: [int(pass_id) for p, pass_id in pos_pass_tags if pass_id > 0 and p == pos] for pos, _ in pos_pass_tags
        }
        pos_pass_dict = {pos: passes for pos, passes in pos_pass_dict.items() if len(passes) > 1}

        for position, passes in pos_pass_dict.items():
            # create groups (size >1) of staves that are the same for consecutive passes
            groups = []
            first = passes[0]
            nextpass = None
            for currpass, nextpass in zip(passes, passes[1:]):
                if first != currpass and not all(
                    compare(beat.get_notes(position, currpass), beat.get_notes(position, nextpass), same)
                    for beat in gongan.beats
                ):
                    # Reached last pass of a group with size >1.
                    groups.append([first, currpass])
                    first = nextpass
            # Create the last group if its size is >1.
            if nextpass == passes[-1] and first != nextpass:
                groups.append([first, nextpass])
            # Process the groups: keep only the first stave of each group and modify the pass indicator of its tag.
            for group in groups:
                pos_pass_tags[position, group[0]] = (
                    pos_pass_tags[position, group[0]].split(":")[0] + f":{group[0]}-{group[1]}"
                )
                for passid in range(group[0] + 1, group[1] + 1):
                    del pos_pass_tags[position, passid]

    # Define the possible combinations of positions for which aggregation should be considered.
    # pylint: disable = invalid-name
    GANGSA_P = [Position.PEMADE_POLOS, Position.KANTILAN_POLOS]
    GANGSA_S = [Position.PEMADE_SANGSIH, Position.KANTILAN_SANGSIH]
    GANGSA = GANGSA_P + GANGSA_S
    REYONG_13 = [Position.REYONG_1, Position.REYONG_3]
    REYONG_24 = [Position.REYONG_2, Position.REYONG_4]
    REYONG = REYONG_13 + REYONG_24
    # pylint: enable = invalid-name
    passids = set(pid for _, pid in pos_pass_combis)
    # Try aggregating on the highest level first.
    for passid in passids:
        if not try_to_aggregate_pos(GANGSA, passid, "GANGSA"):
            try_to_aggregate_pos(GANGSA_P, passid, "GANGSA_P")
            try_to_aggregate_pos(GANGSA_S, passid, "GANGSA_S")
        if not try_to_aggregate_pos(REYONG, passid, "REYONG"):
            try_to_aggregate_pos(REYONG_13, passid, "REYONG_13")
            try_to_aggregate_pos(REYONG_24, passid, "REYONG_24")

    # Aggregate similar passes
    aggregate_passes()
    return pos_pass_tags
