from dataclasses import dataclass
from typing import Callable

from src.common.classes import Beat
from src.common.constants import Position, Stroke
from src.common.notes import Note
from src.common.rules import RulesEngine
from src.settings.classes import RunSettings, SettingsMidiInfo


@dataclass
class NotePattern:
    position: Position
    beat_fullid: str
    passnr: int
    note: Note
    pattern: list[Note]

    @property
    def key(self) -> str:
        """Returns a unique key for the note to which the pattern belongs"""
        return f"{self.position}|{self.beat_fullid}|{self.passnr}|{self.note.symbol}|{self.note.uniqueid}"


class NotePatternGenerator:
    """Generates note patterns for special notes types such as tremolo"""

    def __init__(self, run_settings: RunSettings):
        self.run_settings = run_settings

    @classmethod
    def notes_to_str(cls, measure: list[Note]) -> str:
        """Returns the concatenated symbols of the given list of notes"""
        try:
            return "".join([note.symbol for note in measure])
        except:  # pylint: disable=bare-except
            return ""

    def update_grace_notes_octaves(self, beat: Beat, position: Position, passnr: int) -> list[NotePattern]:
        """Updates the octave of any grace note found in measure. The octave is set by checking
            the note that follows the grace minimizing the 'interval' between both notes.

        Args:
            measure (list[Note]): list of notes that should be checked for grace notes.
        Raises:
            ValueError: if a grace note is not followed by a melodic note.
        Returns:
            list[Note]: Te updated llist
        """

        # updated_measure = []
        patterns: list[NotePattern] = []
        notes = beat.measures[position].passes[passnr].notes

        for note, nextnote in zip(notes.copy(), notes.copy()[1:] + [None]):
            if note.stroke == Stroke.GRACE_NOTE and note.is_melodic():
                if not nextnote or not nextnote.is_melodic:
                    raise ValueError("Grace note not followed by melodic note in %s" % self.notes_to_str(notes))
                tones = RulesEngine.get_tones_within_range(note.to_tone(), note.position, match_octave=False)
                # pylint: disable=cell-var-from-loop
                nearest = sorted(tones, key=lambda x: abs(RulesEngine.interval(x, nextnote.to_tone())))[0]
                # pylint: enable=cell-var-from-loop
                nearest_grace_note = note.model_copy_x(octave=nearest.octave)
                # updated_measure.append(nearest_grace_note)
                patterns.append(
                    NotePattern(
                        position=position,
                        beat_fullid=beat.full_id,
                        passnr=passnr,
                        note=note,
                        pattern=[nearest_grace_note.to_pattern_note()],
                    )
                )

        return patterns

    def generate_tremolo(
        self, beat: Beat, position: Position, passnr: int, errorlogger: Callable = None
    ) -> list[NotePattern]:
        """Generates the note sequence for a tremolo.
            TREMOLO: The duration and pitch will be that of the given note.
            TREMOLO_ACCELERATING: The pitch will be that of the given note(s), the duration will be derived
            from the TREMOLO_ACCELERATING_PATTERN.
            The generated notes are marked as 'autogenerated'. This value will be used when generating
            (PDF) notation from the score object.

                Args:
            measure (list[Note]): One or two notes on which to base the tremolo (piitch only)

        Returns:
            list[Note]: The resulting notes
        """
        midi: SettingsMidiInfo = self.run_settings.midi
        tremolo: SettingsMidiInfo.TremoloInfo = midi.tremolo
        patterns: list[NotePattern] = []
        notes = beat.measures[position].passes[passnr].notes
        curr_noteseq = 0

        while curr_noteseq < len(notes):
            # Scan the measure for tremolo notes
            tremolo_notes: list[Note] = []
            tremolo_noteseqs: list[int] = []
            # note = notes.pop(0)
            if not notes[curr_noteseq].stroke in (Stroke.TREMOLO, Stroke.TREMOLO_ACCELERATING):
                curr_noteseq += 1
                # updated_measure.append(note)
                continue
            tremolo_notes.append(notes[curr_noteseq])
            tremolo_noteseqs.append(curr_noteseq)
            if (
                curr_noteseq < len(notes) - 1
                and notes[curr_noteseq].stroke is Stroke.TREMOLO_ACCELERATING
                and notes[curr_noteseq + 1].stroke is Stroke.TREMOLO_ACCELERATING
            ):
                # Two successive TREMOLO_ACCELERATING notes will be processed together
                tremolo_notes.append(notes[curr_noteseq + 1])
                tremolo_noteseqs.append(curr_noteseq + 1)

            # Generate the tremolo pattern

            generated_notes = []

            if tremolo_notes[0].stroke is Stroke.TREMOLO:
                note = tremolo_notes[0]
                nr_of_notes = round(note.duration * tremolo.notes_per_quarternote)
                duration = note.duration / nr_of_notes
                for count in range(nr_of_notes):
                    # Mark the additional tremolo_notes as 'autogenerated': this will be used when generating (PDF) notation from the score object.
                    generated_notes.append(
                        note.model_copy(update={"duration": duration, "autogenerated": count > 0}).to_pattern_note()
                    )
            elif tremolo_notes[0].stroke is Stroke.TREMOLO_ACCELERATING:
                durations = [i / midi.base_note_time for i in tremolo.accelerating_pattern]
                note_idx = 0  # Index of the next note to select from the `tremolo_notes` list
                tot_duration = 0
                for count, (duration, velocity) in enumerate(zip(durations, tremolo.accelerating_velocity)):
                    generated_notes.append(
                        # tremolo_notes[note_idx] if count < len(tremolo_notes) else
                        tremolo_notes[note_idx]
                        .model_copy(update={"duration": duration, "velocity": velocity, "autogenerated": count > 0})
                        .to_pattern_note()
                    )
                    tot_duration += duration
                    note_idx = (note_idx + 1) % len(tremolo_notes)

                for count, (seq, note) in enumerate(zip(tremolo_noteseqs, tremolo_notes)):
                    notes[tremolo_noteseqs[count]] = tremolo_notes[count].model_copy(
                        update={"duration": tot_duration if count == 0 else 0}
                    )
            elif errorlogger:
                errorlogger("Unexpected tremolo type %s.", tremolo_notes[0].stroke)

            patterns.append(
                NotePattern(
                    position=position,
                    beat_fullid=beat.full_id,
                    passnr=passnr,
                    note=notes[tremolo_noteseqs[0]],
                    pattern=generated_notes,
                )
            )
            for seq in tremolo_noteseqs[1:]:
                patterns.append(
                    NotePattern(
                        position=position,
                        beat_fullid=beat.full_id,
                        passnr=passnr,
                        note=notes[seq],
                        pattern=[],
                    )
                )

            curr_noteseq += len(tremolo_notes)

        return patterns
