from dataclasses import dataclass
from typing import Callable

from src.common.classes import Beat
from src.common.constants import Position, Stroke
from src.common.notes import Note
from src.settings.classes import RunSettings, SettingsMidiInfo


@dataclass
class NotePattern:
    position: Position
    beat_fullid: str
    passnr: int
    note: Note
    pattern: list[Note]

    @property
    def key(self) -> str:
        """Returns a unique key for the note to which the pattern belongs"""
        return f"{self.position}|{self.beat_fullid}|{self.passnr}|{self.note.symbol}|{self.note.uniqueid}"


class NotePatternGenerator:
    """Generates note patterns for special notes types such as tremolo"""

    def __init__(self, run_settings: RunSettings):
        self.run_settings = run_settings

    @classmethod
    def notes_to_str(cls, measure: list[Note]) -> str:
        """Returns the concatenated symbols of the given list of notes"""
        try:
            return "".join([note.symbol for note in measure])
        except:  # pylint: disable=bare-except
            return ""

    def generate_tremolo(
        self, beat: Beat, position: Position, passnr: int, errorlogger: Callable = None
    ) -> list[NotePattern]:
        """Generates the note sequence for a tremolo.
            TREMOLO: The duration and pitch will be that of the given note.
            TREMOLO_ACCELERATING: The pitch will be that of the given note(s), the duration will be derived
            from the TREMOLO_ACCELERATING_PATTERN.
            The generated notes are marked as 'autogenerated'. This value will be used when generating
            (PDF) notation from the score object.

                Args:
            measure (list[Note]): One or two notes on which to base the tremolo (piitch only)

        Returns:
            list[Note]: The resulting notes
        """
        midi: SettingsMidiInfo = self.run_settings.midi
        tremolo: SettingsMidiInfo.TremoloInfo = midi.tremolo
        patterns: list[NotePattern] = []
        notes: list[Note | NotePattern] = beat.measures[position].passes[passnr].notes
        curr_noteseq = 0

        while curr_noteseq < len(notes):
            # Scan the measure for tremolo notes
            tremolo_patterns: list[Note] = []
            tremolo_noteseqs: list[int] = []
            # note = notes.pop(0)
            if not isinstance(notes[curr_noteseq], NotePattern) or notes[curr_noteseq].notepattern not in (
                Stroke.TREMOLO,
                Stroke.TREMOLO_ACCELERATING,
            ):
                curr_noteseq += 1
                # updated_measure.append(note)
                continue
            tremolo_patterns.append(notes[curr_noteseq])
            tremolo_noteseqs.append(curr_noteseq)
            if (
                curr_noteseq < len(notes) - 1
                and notes[curr_noteseq].stroke is Stroke.TREMOLO_ACCELERATING
                and notes[curr_noteseq + 1].stroke is Stroke.TREMOLO_ACCELERATING
            ):
                # Two successive TREMOLO_ACCELERATING notes will be processed together
                tremolo_patterns.append(notes[curr_noteseq + 1])
                tremolo_noteseqs.append(curr_noteseq + 1)

            # Generate the tremolo pattern

            generated_notes = []

            if tremolo_patterns[0].stroke is Stroke.TREMOLO:
                note = tremolo_patterns[0]
                nr_of_notes = round(note.duration * tremolo.notes_per_quarternote)
                duration = note.duration / nr_of_notes
                for count in range(nr_of_notes):
                    # Mark the additional tremolo_notes as 'autogenerated': this will be used when generating (PDF) notation from the score object.
                    generated_notes.append(
                        note.model_copy(update={"duration": duration, "autogenerated": count > 0}).to_pattern_note()
                    )
            elif tremolo_patterns[0].stroke is Stroke.TREMOLO_ACCELERATING:
                durations = [i / midi.base_note_time for i in tremolo.accelerating_pattern]
                note_idx = 0  # Index of the next note to select from the `tremolo_notes` list
                tot_duration = 0
                for count, (duration, velocity) in enumerate(zip(durations, tremolo.accelerating_velocity)):
                    generated_notes.append(
                        # tremolo_notes[note_idx] if count < len(tremolo_notes) else
                        tremolo_patterns[note_idx]
                        .model_copy(update={"duration": duration, "velocity": velocity, "autogenerated": count > 0})
                        .to_pattern_note()
                    )
                    tot_duration += duration
                    note_idx = (note_idx + 1) % len(tremolo_patterns)

                for count, (seq, note) in enumerate(zip(tremolo_noteseqs, tremolo_patterns)):
                    notes[tremolo_noteseqs[count]] = tremolo_patterns[count].model_copy(
                        update={"duration": tot_duration if count == 0 else 0}
                    )
            else:
                raise ValueError("Unexpected tremolo type %s." % tremolo_patterns[0].stroke)

            patterns.append(
                NotePattern(
                    position=position,
                    beat_fullid=beat.full_id,
                    passnr=passnr,
                    note=notes[tremolo_noteseqs[0]],
                    pattern=generated_notes,
                )
            )
            for seq in tremolo_noteseqs[1:]:
                patterns.append(
                    NotePattern(
                        position=position,
                        beat_fullid=beat.full_id,
                        passnr=passnr,
                        note=notes[seq],
                        pattern=[],
                    )
                )

            curr_noteseq += len(tremolo_patterns)

        return patterns
