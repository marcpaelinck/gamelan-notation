from dataclasses import dataclass
from typing import Callable

from src.common.classes import Beat
from src.common.constants import PatternType, Position, Stroke
from src.common.notes import Note, NoteFactory, Pattern
from src.settings.classes import RunSettings, SettingsMidiInfo


@dataclass
class NotePattern:
    position: Position
    beat_fullid: str
    passnr: int
    note: Note
    pattern: list[Note]

    @property
    def key(self) -> str:
        """Returns a unique key for the note to which the pattern belongs"""
        return f"{self.position}|{self.beat_fullid}|{self.passnr}|{self.note.symbol}|{self.note.uniqueid}"


class NotePatternGenerator:
    """Generates note patterns for special notes types such as tremolo"""

    def __init__(self, run_settings: RunSettings):
        self.run_settings = run_settings

    @classmethod
    def notes_to_str(cls, measure: list[Note]) -> str:
        """Returns the concatenated symbols of the given list of notes"""
        try:
            return "".join([note.symbol for note in measure])
        except:  # pylint: disable=bare-except
            return ""

    def generate_tremolo(self, beat: Beat, position: Position, passnr: int, errorlogger: Callable = None) -> None:
        """Generates the note sequence for a tremolo.
            TREMOLO: The duration and pitch will be that of the given note.
            TREMOLO_ACCELERATING: The pitch will be that of the given note(s), the duration will be derived
            from the TREMOLO_ACCELERATING_PATTERN.
            The generated notes are marked as 'autogenerated'. This value will be used when generating
            (PDF) notation from the score object.

                Args:
            measure (list[Note]): One or two notes on which to base the tremolo (piitch only)

        Returns:
            list[Note]: The resulting notes
        """
        midi: SettingsMidiInfo = self.run_settings.midi
        tremolo: SettingsMidiInfo.TremoloInfo = midi.tremolo
        # patterns: list[NotePattern] = []
        notes: list[Note] = beat.measures[position].passes[passnr].notes
        curr_noteseq = 0

        while curr_noteseq < len(notes):
            # Search the measure for tremolo notes
            tremolo_patterns: list[Pattern] = []
            tremolo_noteseqs: list[int] = []
            if notes[curr_noteseq].effect not in (PatternType.TREMOLO, PatternType.TREMOLO_ACCELERATING):
                curr_noteseq += 1
                # updated_measure.append(note)
                continue
            tremolo_patterns.append(notes[curr_noteseq])
            tremolo_noteseqs.append(curr_noteseq)
            if (
                curr_noteseq < len(notes) - 1
                and notes[curr_noteseq].effect is PatternType.TREMOLO_ACCELERATING
                and notes[curr_noteseq + 1].effect is PatternType.TREMOLO_ACCELERATING
            ):
                # Two successive TREMOLO_ACCELERATING notes will be processed together
                tremolo_patterns.append(notes[curr_noteseq + 1])
                tremolo_noteseqs.append(curr_noteseq + 1)

            # Generate the tremolo pattern

            generated_notes = []

            if tremolo_patterns[0].effect is PatternType.TREMOLO:
                pattern = tremolo_patterns[0]
                nr_of_notes = round(pattern.duration * tremolo.notes_per_quarternote)
                note_value = pattern.note_value / nr_of_notes
                attributes = pattern.model_dump() | {"note_value": note_value}
                generated_notes.append([NoteFactory.create_note(**attributes) for _ in range(nr_of_notes)])
            elif tremolo_patterns[0].effect is PatternType.TREMOLO_ACCELERATING:
                durations = [i / midi.base_note_time for i in tremolo.accelerating_pattern]
                note_idx = 0  # Index of the next pattern to select from the `tremolo_patterns` list
                for _, (duration, velocity) in enumerate(zip(durations, tremolo.accelerating_velocity)):
                    attributes = tremolo_patterns[note_idx].model_dump()
                    attributes |= {"effect": Stroke.OPEN, "note_value": duration, "relative_velocity": velocity}
                    generated_notes.append(NoteFactory.create_note(**attributes))
                    note_idx = (note_idx + 1) % len(tremolo_patterns)

            else:
                raise ValueError("Unexpected tremolo type %s." % tremolo_patterns[0].effect)

            # Assign the generated notes to the first pattern.
            tremolo_patterns[0].pattern.extend(generated_notes)
            curr_noteseq += len(tremolo_patterns)
