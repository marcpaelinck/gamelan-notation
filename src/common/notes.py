from dataclasses import dataclass
from enum import StrEnum
from typing import ClassVar, override
from uuid import uuid4

from pydantic import UUID4, BaseModel, ConfigDict, Field, computed_field

from src.common.constants import (
    Effect,
    Octave,
    Pitch,
    Position,
    RuleValue,
    Stroke,
    SustainType,
)
from src.settings.classes import RunSettings
from src.settings.font_to_valid_notes import ValidNoteGenerator
from src.settings.settings import RunSettingsListener


class Tone(BaseModel):
    # A tone is a combination of a pitch and an octave.
    model_config = ConfigDict(extra="ignore", frozen=True)
    pitch: Pitch
    octave: int | None
    transformation: RuleValue | None = None

    MELODIC_PITCHES: ClassVar[list[Pitch]] = [
        Pitch.DING,
        Pitch.DONG,
        Pitch.DENG,
        Pitch.DEUNG,
        Pitch.DUNG,
        Pitch.DANG,
        Pitch.DAING,
    ]

    @computed_field
    @property
    def key(self) -> int:
        """Returns a sorting key to order the tones by frequency"""
        return self.pitch.sequence + self.octave * 10 if self.is_melodic() else 0

    def is_melodic(self):
        """True if the the tone's pitch is one of DING...DAING"""
        return self.pitch in Tone.MELODIC_PITCHES


@dataclass
class MidiNote:
    relative_velocity: float = 1.0
    midinote: tuple[int, ...] = (127,)  # 0..128, used when generating MIDI output.


class GenericNote(BaseModel):
    model_config = ConfigDict(extra="ignore", frozen=True)
    symbol: str
    pitch: Pitch
    octave: Octave | None = None
    effect: Effect
    relative_velocity: float = 1.0
    note_value: float = None  # 1 = whole note

    def to_tone(self) -> Tone:
        return Tone(pitch=self.pitch, octave=self.octave)

    def is_melodic(self) -> bool:
        return self.to_tone().is_melodic()


class Note(GenericNote):
    model_config = ConfigDict(extra="ignore", frozen=True)

    class Fields(StrEnum):
        MODEL_CONFIG = "model_config"
        SYMBOL = "symbol"
        PITCH = "pitch"
        OCTAVE = "octave"
        EFFECT = "effect"
        RELATIVE_VELOCITY = "relative_velocity"
        NOTE_VALUE = "note_value"
        POSITION = "position"
        AUTOGENERATED = "autogenerated"
        SUSTAIN_TYPE = "sustaintype"
        UUID = "uuid"

    position: Position
    autogenerated: bool = False
    transformation: RuleValue | None = None
    sustaintype: SustainType = SustainType.OFF_ON_NEXT_NOTE
    uuid: UUID4 = uuid4()

    @property
    def duration(self) -> float:
        return self.note_value


class Pattern(GenericNote):
    position: Position
    pattern: list[Note] = Field(default_factory=list)
    transformation: RuleValue | None = None

    @property
    def duration(self) -> float:
        return sum(note.duration for note in self.pattern)


class NoteFactory(BaseModel, RunSettingsListener):
    _POS_P_O_E_V_fields: ClassVar[tuple[str]]
    _NOTE_GENERATOR: ClassVar[ValidNoteGenerator]
    VALID_GENERICNOTES: ClassVar[set[GenericNote]]
    _SYMBOL_TO_GENERICNOTE: ClassVar[dict[str, GenericNote]]
    VALID_NOTES: ClassVar[set[Note]]
    _POS_P_O_E_V_TO_VALID_NOTE: ClassVar[dict[tuple[Position, Pitch, int, Effect, float], Note]]

    @classmethod
    @override
    def cls_initialize(cls, run_settings: RunSettings):
        """Initializes the class's dict constants"""
        cls._POS_P_O_E_V_fields = [
            Note.Fields.POSITION,
            Note.Fields.PITCH,
            Note.Fields.OCTAVE,
            Note.Fields.EFFECT,
            Note.Fields.NOTE_VALUE,
        ]
        cls._NOTE_GENERATOR = ValidNoteGenerator(run_settings)
        valid_records = cls._NOTE_GENERATOR.get_valid_note_records()
        cls.VALID_NOTES = {Note(**record) for record in valid_records}
        cls.VALID_GENERICNOTES = {GenericNote(**record) for record in valid_records}
        cls._POS_P_O_E_V_TO_VALID_NOTE = {
            (n.position, n.pitch, n.octave, n.effect, n.note_value): n for n in cls.VALID_NOTES
        }
        cls._SYMBOL_TO_GENERICNOTE = {n.symbol: n for n in cls.VALID_GENERICNOTES}
        # cls._CHAR_TO_PITCH_NOTEVALUE_MODIFIER = {
        #     char[FontFields.SYMBOL]: (char[FontFields.PITCH], char[FontFields.NOTE_VALUE], char[FontFields.MODIFIER])
        #     for char in run_settings.data.font
        # }

    @classmethod
    def genericnote_from_notesymbol(cls, notesymbol: str) -> GenericNote:
        """Returns a GenericNote instance that corresponds with the given note symbol.
        Raises a ValueError if the note symbol is incorrect."""
        symbol = cls._NOTE_GENERATOR.normalize_symbol(notesymbol)
        note: Note = cls._SYMBOL_TO_GENERICNOTE.get(symbol, None)
        if note:
            return note.model_copy()
        raise ValueError("Incorrect note symbol %s" % notesymbol)

    @classmethod
    def clone_genericnote(cls, note: GenericNote, /, **kwargs) -> GenericNote:
        """Creates a copy of the given note with modified attributes.
        Args:
            note (Note): the note to copy.
            kwargs: Note attributes that should be substituted.
        Returns:
            Note: New Note instance
        """
        new_kwargs = note.model_dump() | kwargs
        # TODO: add validation
        return GenericNote(**new_kwargs)

    @classmethod
    def create_note(
        cls, position: Position, pitch: Pitch, octave: int | None, effect: Effect, note_value: float | None, **kwargs
    ) -> Note:
        """Returns a Note instance for the given combination of attributes. Tries to find a match for the given note value.
        This will ensure that the note symbol matches the note value. If the note value is not 1, .5 or .25, the note
        symbol will match that of note value 1.
        Throws an exception if the combination of attributes is invalid."""

        key = (position, pitch, octave, effect, note_value)
        note: Note = cls._POS_P_O_E_V_TO_VALID_NOTE.get(key, None)
        if not note and kwargs.get(Note.Fields.AUTOGENERATED, None) is True:
            # Autogenerated notes may have any note_value. Use note with note_value 1.0 as 'template'.
            key = (position, pitch, octave, effect, 1.0)
            note = cls._POS_P_O_E_V_TO_VALID_NOTE.get(key, None)
        if note:
            return note.model_copy(update={"note_value": float(note_value)} | kwargs)
        raise ValueError("Incorrect combination %s, %s, %s, %s" % (position, pitch, octave, effect))

    @classmethod
    def clone_note(cls, note: Note, /, **kwargs) -> Note:
        """Creates a copy of the given note with modified attributes.
        Args:
            note (Note): the note to copy.
            kwargs: Note attributes that should be substituted.
        Returns:
            Note: New Note instance
        """
        new_kwargs = {key: val for key, val in note.model_dump().items() if key in cls._POS_P_O_E_V_fields} | kwargs
        return cls.create_note(**new_kwargs)

    @classmethod
    def create_rest(cls, position: Position, resttype: Pitch, note_value: float = 1.0, **kwargs):
        return cls.create_note(
            position=position, pitch=resttype, octave=None, effect=Stroke.NONE, note_value=note_value, **kwargs
        )

    @classmethod
    def get_all_p_o_e(cls, position: Position) -> list[tuple[Pitch, Octave, Effect]]:
        return set((tup[1], tup[2], tup[3]) for tup in cls._POS_P_O_E_V_TO_VALID_NOTE.keys() if tup[0] == position)
