from dataclasses import dataclass, fields
from enum import StrEnum
from typing import ClassVar, Optional, override
from uuid import UUID, uuid4

from pydantic import BaseModel, ConfigDict, Field, computed_field

from src.common.constants import (
    Effect,
    Modifier,
    Octave,
    Pitch,
    Position,
    RuleValue,
    Stroke,
)
from src.settings.classes import RunSettings
from src.settings.constants import FontFields, NoteFields
from src.settings.font_to_valid_notes import get_note_records
from src.settings.settings import RunSettingsListener


class Tone(BaseModel):
    # A tone is a combination of a pitch and an octave.
    model_config = ConfigDict(extra="ignore", frozen=True)
    pitch: Pitch
    octave: int | None
    transformation: RuleValue | None = None

    MELODIC_PITCHES: ClassVar[list[Pitch]] = [
        Pitch.DING,
        Pitch.DONG,
        Pitch.DENG,
        Pitch.DEUNG,
        Pitch.DUNG,
        Pitch.DANG,
        Pitch.DAING,
    ]

    @computed_field
    @property
    def key(self) -> int:
        """Returns a sorting key to order the tones by frequency"""
        return self.pitch.sequence + self.octave * 10 if self.is_melodic() else 0

    def is_melodic(self):
        """True if the the tone's pitch is one of DING...DAING"""
        return self.pitch in Tone.MELODIC_PITCHES


@dataclass
class MidiNote:
    relative_velocity: float = 1.0
    midinote: tuple[int, ...] = (127,)  # 0..128, used when generating MIDI output.


class NoteSymbol(BaseModel):
    """A representation of a note's font characters:
    the characters are converted to pitch and modifier values.
    """

    pitch: Pitch
    note_value: float | None = None
    symbol: str
    modifiers: list[Modifier] = Field(default_factory=list)

    @classmethod
    def fieldnames(cls) -> list[str]:
        """Returns the field names"""
        return [name for name in fields(cls)]  # pylint: disable=not-an-iterable


class GenericNote(BaseModel):
    symbol: str
    pitch: Pitch
    octave: Octave | None = None
    effect: Effect
    relative_velocity: float = 1.0
    note_value: float = None  # 1 = whole note
    notesymbol: NoteSymbol | None

    def to_tone(self) -> Tone:
        return Tone(pitch=self.pitch, octave=self.octave)

    def is_melodic(self) -> bool:
        return self.to_tone().is_melodic()


class Note(GenericNote):
    class Fields(StrEnum):
        PITCH = "pitch"
        OCTAVE = "octave"
        EFFECT = "effect"
        PATTERN = "pattern"
        NOTE_VALUE = "note_value"
        NOTESYMBOL = "notesymbol"
        SYMBOL = "symbol"
        MODIFIERS = "modifiers"

    model_config = ConfigDict(extra="ignore", frozen=True, revalidate_instances="always")

    position: Position
    realization: list[MidiNote] = Field(default_factory=list)
    autogenerated: bool = False
    uniqueid: UUID = Field(default_factory=uuid4)

    @property
    def duration(self) -> float:
        return self.note_value


class Pattern(GenericNote):
    position: Position
    pattern: list[Note] = Field(default_factory=list)

    @property
    def duration(self) -> float:
        return sum(note.duration for note in self.pattern)


class NoteFactory(BaseModel, RunSettingsListener):
    # POS_P_O_E stands for Position, Pitch, Octave, Effect
    _POS_P_O_E_TO_NOTE: ClassVar[tuple[Position, int, Effect]]
    VALIDNOTES: ClassVar[list["Note"]]
    _CHAR_TO_PITCH_NOTEVALUE_MODIFIER: ClassVar[dict[str, tuple[Pitch, int | None, Modifier]]]
    _FONT_SORTING_ORDER: ClassVar[dict[str, int]]

    @classmethod
    @override
    def cls_initialize(cls, run_settings: RunSettings):
        """Initializes the class's dict constants"""
        font = run_settings.data.font
        mod_list = list(Modifier)
        cls._FONT_SORTING_ORDER = {sym[FontFields.SYMBOL]: mod_list.index(sym[FontFields.MODIFIER]) for sym in font}
        valid_records = get_note_records(run_settings)
        valid_records = [record | {Note.Fields.NOTESYMBOL: None} for record in valid_records]
        cls.VALIDNOTES = [Note(**record) for record in valid_records]
        cls._POS_P_O_E_TO_NOTE = {(n.position, n.pitch, n.octave, n.effect): n for n in cls.VALIDNOTES}
        cls._CHAR_TO_PITCH_NOTEVALUE_MODIFIER = {
            char[FontFields.SYMBOL]: (char[FontFields.PITCH], char[FontFields.NOTE_VALUE], char[FontFields.MODIFIER])
            for char in run_settings.data.font
        }

    @classmethod
    def normalized_symbol(cls, symbol: str) -> str:
        """Returns the note symbol with the characters in a normalized sequence"""
        return "".join(sorted(symbol, key=lambda c: cls._FONT_SORTING_ORDER.get(c, 99)))

    @classmethod
    def clone_generic_note(cls, note: GenericNote, /, **kwargs) -> GenericNote:
        """Creates a copy of the given note with modified attributes.
        Args:
            note (Note): the note to copy.
            kwargs: Note attributes that should be substituted.
        Returns:
            Note: New Note instance
        """
        new_kwargs = note.model_dump() | kwargs
        # TODO: add validation
        return GenericNote(**new_kwargs)

    @classmethod
    def clone_note(cls, note: Note, /, **kwargs) -> Note:
        """Creates a copy of the given note with modified attributes.
        Args:
            note (Note): the note to copy.
            kwargs: Note attributes that should be substituted.
        Returns:
            Note: New Note instance
        """
        new_kwargs = note.model_dump() | kwargs
        # TODO: add validation
        return Note(**new_kwargs)

    @classmethod
    def create_notesymbol(cls, symbol: str) -> NoteSymbol:
        pitch = None
        note_value = None
        modifiers = []
        symbol = NoteFactory.normalized_symbol(symbol)
        for char in symbol:
            if char not in cls._CHAR_TO_PITCH_NOTEVALUE_MODIFIER:
                raise KeyError("Unrecognized character %s in %s" % (char, symbol))
            pitch_val, notevalue_val, mod_val = cls._CHAR_TO_PITCH_NOTEVALUE_MODIFIER[char]
            if mod_val != Modifier.NONE:
                modifiers.append(mod_val)
            if pitch_val and pitch_val != Pitch.NONE and pitch:
                raise ValueError("Encountered two pitch symbols in note symbol %s" % symbol)
            if not pitch or pitch_val != Pitch.NONE:
                pitch = pitch_val
            if pitch_val not in (None, Pitch.NONE):
                note_value = notevalue_val

        # if not pitch:
        #     raise KeyError("Missing pitch character in %s" % symbol)
        return NoteSymbol(pitch=pitch, modifiers=modifiers, note_value=note_value, symbol=symbol)

    @classmethod
    def create_note(
        cls, position: Position, pitch: Pitch, octave: int | None, effect: Effect, note_value: float | None, **kwargs
    ) -> Optional[NoteSymbol]:
        note_record = (position, pitch, octave, effect)
        note: Note = cls._POS_P_O_E_TO_NOTE.get(note_record, None)
        if note:
            return note.model_copy(update={"note_value": note_value} | kwargs)
        return None

    @classmethod
    def get_whole_rest_note(cls, position: Position, resttype: Pitch):
        return cls.create_note(position=position, pitch=resttype, octave=None, effect=Stroke.NONE, note_value=1)

    @classmethod
    def get_all_p_o_e(cls, position: Position) -> list[tuple[Pitch, Octave, Effect]]:
        return set((tup[1], tup[2], tup[3]) for tup in cls._POS_P_O_E_TO_NOTE.keys() if tup[0] == position)
