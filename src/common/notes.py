from dataclasses import asdict, dataclass, fields
from typing import Any, ClassVar, Literal, Optional, override
from uuid import UUID, uuid4

from pydantic import BaseModel, ConfigDict, Field, computed_field

from src.common.constants import (
    Duration,
    Modifier,
    Octave,
    PatternType,
    Pitch,
    Position,
    RuleParameter,
    RuleType,
    RuleValue,
    Stroke,
)
from src.settings.classes import RunSettings
from src.settings.constants import FontFields
from src.settings.font_to_valid_notes import get_note_records
from src.settings.settings import RunSettingsListener


class Tone(BaseModel):
    # A tone is a combination of a pitch and an octave.
    model_config = ConfigDict(extra="ignore", frozen=True)
    pitch: Pitch
    octave: int | None
    transformation: RuleValue | None = None

    MELODIC_PITCHES: ClassVar[list[Pitch]] = [
        Pitch.DING,
        Pitch.DONG,
        Pitch.DENG,
        Pitch.DEUNG,
        Pitch.DUNG,
        Pitch.DANG,
        Pitch.DAING,
    ]

    @computed_field
    @property
    def key(self) -> int:
        """Returns a sorting key to order the tones by frequency"""
        return self.pitch.sequence + self.octave * 10 if self.is_melodic() else 0

    def is_melodic(self):
        """True if the the tone's pitch is one of DING...DAING"""
        return self.pitch in Tone.MELODIC_PITCHES


@dataclass
class MidiNote:
    duration: float
    rest_after: float
    relative_velocity: float = 1.0
    midinote: tuple[int, ...] = (127,)  # 0..128, used when generating MIDI output.


class GenericNote(BaseModel):
    pitch: Pitch
    symbol: str
    modifiers: list[Modifier] = Field(default_factory=list)

    @classmethod
    def fieldnames(cls) -> list[str]:
        """Returns the field names"""
        return [name for name in fields(cls)]  # pylint: disable=not-an-iterable

    @property
    def octave(self) -> Literal[0, 1, 2, None]:
        return (
            None
            if self.pitch not in Tone.MELODIC_PITCHES
            else 2 if Modifier.OCTAVE_2 in self.modifiers else 0 if Modifier.OCTAVE_0 in self.modifiers else 1
        )


class BaseNote(BaseModel):
    pitch: Pitch = Pitch.NONE
    octave: Octave | None = None
    stroke: Stroke = Stroke.NONE
    generic_note: GenericNote = None
    note_value: float = 1  # 1 = whole note

    def to_tone(self) -> Tone:
        return Tone(pitch=self.pitch, octave=self.octave)

    def is_melodic(self) -> bool:
        return self.to_tone().is_melodic()

    def duration(self) -> float:
        return self.note_value


class Note(BaseNote):
    model_config = ConfigDict(extra="ignore", frozen=True, revalidate_instances="always")

    position: Position
    realization: list[MidiNote] = Field(default_factory=list)
    autogenerated: bool = False
    uniqueid: UUID = Field(default_factory=uuid4)


class NotePattern(BaseModel):
    patterntype: PatternType = PatternType.NONE
    pattern: list[Note]

    @override
    def duration(self) -> float:
        return sum(note.note_value for note in self.pattern)


class NoteFactory(BaseModel, RunSettingsListener):
    # POS_P_O_S_D_R stands for Position, Pitch, Octave, Stroke, Duration, Rest After
    # This uniquely defines a Note object that is mapped to a single MIDI note.
    _VALID_POS_P_O_S_D_R: ClassVar[list[tuple[Position, Pitch, Octave, Stroke, Duration, Duration]]]
    VALIDNOTES: ClassVar[list["Note"]]
    _SYMBOL_TO_UNBOUNDNOTE: ClassVar[dict[(str), GenericNote]]
    _CHAR_TO_PITCH_MODIFIER: ClassVar[dict[str, tuple[Pitch, Modifier]]]
    # The following attributes uniquely define a note in VALIDNOTES
    _POS_P_O_S_D_R: ClassVar[tuple[str]] = ("position", "pitch", "octave", "stroke", "duration", "rest_after")
    # The following attributes may never be updated
    _FORBIDDEN_UPDATE_ATTRIBUTES: ClassVar[tuple[str]] = ("midinote", "rootnote", "sample")
    _FORBIDDEN_COPY_ATTRIBUTES: ClassVar[tuple[str]] = ("uniqueid", "pattern")
    _ANY_DURATION_STROKES: ClassVar[tuple[Stroke]] = (Stroke.EXTENSION, Stroke.TREMOLO, Stroke.TREMOLO_ACCELERATING)
    _ANY_SILENCEAFTER_STROKES: ClassVar[tuple[Stroke]] = (Stroke.SILENCE,)
    _FONT_SORTING_ORDER: ClassVar[dict[str, int]]

    @classmethod
    @override
    def cls_initialize(cls, run_settings: RunSettings):
        """Initializes the class's dict constants"""
        font = run_settings.data.font
        mod_list = list(Modifier)
        cls._FONT_SORTING_ORDER = {sym[FontFields.SYMBOL]: mod_list.index(sym[FontFields.MODIFIER]) for sym in font}

        valid_records = get_note_records(run_settings)
        cls._VALID_POS_P_O_S_D_R = [
            tuple([rec[a] for a in ["position", "pitch", "octave", "stroke", "duration", "rest_after"]])
            for rec in valid_records
        ]
        cls.VALIDNOTES = [Note(**record) for record in valid_records]
        cls._CHAR_TO_PITCH_MODIFIER = {
            char[FontFields.SYMBOL]: (char[FontFields.PITCH], char[FontFields.MODIFIER])
            for char in run_settings.data.font
        }
        # cls._SYMBOL_TO_UNBOUNDNOTE = {
        #     cls.sorted_chars(note[NoteFields.SYMBOL]): UnboundNote(
        #         **{k: v for k, v in note.items() if k in UnboundNote.fieldnames()}
        #     )
        #     for note in note_records
        # }

    @classmethod
    def clone_base_note(cls, note: BaseNote, /, **kwargs) -> BaseNote:
        """Creates a copy of the given note with modified attributes.
        Args:
            note (Note): the note to copy.
            kwargs: Note attributes that should be substituted.
        Returns:
            Note: New Note instance
        """
        new_kwargs = note.model_dump() | kwargs
        # TODO: add validation
        return BaseNote(**new_kwargs)

    @classmethod
    def create_pattern(cls, note: BaseNote, /, **kwargs) -> NotePattern:
        """Creates a copy of the given note with modified attributes.
        Args:
            note (Note): the note to copy.
            kwargs: Note attributes that should be substituted.
        Returns:
            Note: New Note instance
        """
        new_kwargs = note.model_dump() | kwargs
        # TODO: add validation
        return NotePattern(**new_kwargs)

    @classmethod
    def clone_bound_note(cls, note: Note, /, **kwargs) -> Note:
        """Creates a copy of the given note with modified attributes.
        Args:
            note (Note): the note to copy.
            kwargs: Note attributes that should be substituted.
        Returns:
            Note: New Note instance
        """
        new_kwargs = note.model_dump() | kwargs
        # TODO: add validation
        return Note(**new_kwargs)

    @classmethod
    def get_bound_note(
        cls,
        position: Position,
        pitch: Pitch,
        octave: int | None,
        stroke: Stroke,
        duration: float | None,
        rest_after: float | None,
    ) -> Optional[GenericNote]:
        note_record = (position, pitch, octave, stroke, duration, rest_after)
        note: Note = cls._POS_P_O_S_D_R_TO_NOTE.get(note_record, None)
        if note:
            return note.model_copy()
        return None

    @classmethod
    def get_generic_note(cls, symbol: str) -> GenericNote:
        pitch = None
        modifiers = []
        for char in symbol:
            if char not in cls._CHAR_TO_PITCH_MODIFIER:
                raise KeyError("Unrecognized character %s in %s" % (char, symbol))
            pitch_val, mod_val = cls._CHAR_TO_PITCH_MODIFIER[char]
            if mod_val != Modifier.NONE:
                modifiers.append(mod_val)
            if pitch_val != Pitch.NONE and pitch:
                raise ValueError("Encountered two pitch symbols in note symbol %s" % symbol)
            if not pitch or pitch_val != Pitch.NONE:
                pitch = pitch_val
        # if not pitch:
        #     raise KeyError("Missing pitch character in %s" % symbol)
        return GenericNote(pitch=pitch, modifiers=modifiers, symbol=symbol)

    @classmethod
    def _is_valid_combi(
        cls,
        position: Position,
        pitch: Pitch,
        octave: int | None,
        stroke: Stroke,
        duration: float | None,
        rest_after: float | None,
    ) -> Optional["Note"]:
        if stroke in cls._ANY_DURATION_STROKES:
            # accept any duration value
            return any(
                key
                for key in cls._VALID_POS_P_O_S_D_R
                if key[:4] == (position, pitch, octave, stroke) and key[5] == rest_after
            )
        if stroke in cls._ANY_SILENCEAFTER_STROKES:
            # accept any silence value
            return any(
                key for key in cls._VALID_POS_P_O_S_D_R if key[:5] == (position, pitch, octave, stroke, duration)
            )
        return (position, pitch, octave, stroke, duration, rest_after) in cls._VALID_POS_P_O_S_D_R

    # def model_copy(self, update=None) -> Optional["Note"]:  # pylint: disable=arguments-differ
    #     """Overwrites the default model_copy method to allow for validation check.
    #     BaseModel.model_copy does not validate the input data.
    #     """
    #     update = update or {}
    #     forbidden = set(update.keys()).intersection(set(self._FORBIDDEN_UPDATE_ATTRIBUTES))
    #     if any(forbidden):
    #         raise ValueError("Attempt to update one or more protected note value(s): %s" % forbidden)

    #     note_record = self.model_dump(exclude=self._FORBIDDEN_COPY_ATTRIBUTES) | update
    #     search_record = {key: note_record[key] for key in self._POS_P_O_S_D_R}
    #     if search_record["stroke"] in self._ANY_DURATION_STROKES:
    #         update |= {"duration": search_record["duration"]}
    #         search_record["duration"] = 1
    #     if search_record["stroke"] in self._ANY_SILENCEAFTER_STROKES:
    #         update |= {"rest_after": search_record["rest_after"]}
    #         search_record["rest_after"] = 1
    #     update |= {"uniqueid": uuid4()}

    #     valid_note = self._POS_P_O_S_D_R_TO_NOTE.get(tuple(search_record.values()), None)
    #     if not valid_note:
    #         raise ValueError(
    #             (
    #                 "Invalid combination %s OCT%s %s "
    #                 % (search_record["pitch"], search_record["octave"], search_record["stroke"])
    #             )
    #             + (
    #                 "%s %s for %s"
    #                 % ({search_record["duration"]}, {search_record["rest_after"]}, {search_record["position"]})
    #             )
    #         )
    #     updated_args_dict = valid_note.model_dump(exclude=self._FORBIDDEN_COPY_ATTRIBUTES) | update
    #     return Note(**updated_args_dict)

    # def model_copy_x(
    #     self,
    #     **kwargs,
    # ) -> Optional["Note"]:
    #     """Returns a note with the same attributes as the input note, except for the given parameters.
    #        Raises an error if the combination of POS_P_O_S_D_R parameters is not valid.
    #     Returns:
    #         Optional[Note]: A copy of the note with updated parameters or None if invalid.
    #     """
    #     return self.model_copy(update=kwargs)

    @classmethod
    def get_whole_rest_note(cls, position: Position, resttype: Stroke):
        return cls.get_bound_note(
            position=position, pitch=Pitch.NONE, octave=None, stroke=resttype, duration=1, rest_after=0
        ) or cls.get_bound_note(
            position=position, pitch=Pitch.NONE, octave=None, stroke=resttype, duration=0, rest_after=1
        )

    @classmethod
    def get_all_p_o_s(cls, position: Position) -> list[tuple[Pitch, Octave, Stroke]]:
        return set((tup[1], tup[2], tup[3]) for tup in cls._POS_P_O_S_D_R_TO_NOTE.keys() if tup[0] == position)

    @classmethod
    def sorted_chars(cls, chars: str) -> str:
        return "".join(sorted(chars, key=lambda c: cls._FONT_SORTING_ORDER.get(c, 99)))


# class Note(BaseModel):
#     # config revalidate_instances forces validation when using model_copy
#     model_config = ConfigDict(extra="ignore", frozen=True, revalidate_instances="always")
#     symbol: str | None = None
#     velocity: int | None = None  # If None, will be set according to DynamicMeta setting
#     modifier: Modifier | None = Modifier.NONE
#     # midinote: tuple[int, ...] = (127,)  # 0..128, used when generating MIDI output.
#     rootnote: str = ""
#     sample: str = ""  # file name of the (mp3) sample.
#     autogenerated: bool = False  # True: Note does not occur in the source but was generated
#     # to emulate a pattern (e.g. Tremolo). This attribute is used by the PDF generator to skip
#     # Autogenerated notes.
#     uniqueid: UUID = Field(default_factory=uuid4)
#     pattern: list[MidiNote] = Field(default_factory=list)

#     @computed_field
#     @property
#     def pattern_duration(self) -> float:
#         return sum([n.duration + n.rest_after for n in self.pattern])
# return self.duration + self.rest_after

# @field_validator("octave", mode="before")
# @classmethod
# def process_nonevals(cls, value):
#     if isinstance(value, str) and value.upper() == "NONE":
#         return None
#     return value

# @model_validator(mode="after")
# def validate_note(self) -> Self:
#     # No validation before lookups dicts have been initialized.
#     if NoteFactory._is_valid_combi(
#         self.position, self.pitch, self.octave, self.stroke, self.duration, self.rest_after
#     ):
#         return self
#     raise ValueError(
#         f"Invalid combination {self.pitch} OCT{self.octave} {self.stroke} "
#         f"{self.duration} {self.rest_after} for {self.position}"
#     )

# @override
# def model_post_init(self, context: Any, /) -> None:
#     if not self.pattern:
#         self.pattern.append(self.to_pattern_note())  # pylint: disable=no-member
#     else:
#         raise ValueError("pattern is not empty")

# def to_pattern_note(self) -> MidiNote:
#     return MidiNote(**self.model_dump())  # pylint: disable=too-many-function-args

# def model_copy(self, update=None) -> Optional["Note"]:  # pylint: disable=arguments-differ
#     """Overwrites the default model_copy method to allow for validation check.
#     BaseModel.model_copy does not validate the input data.
#     """
#     update = update or {}
#     forbidden = set(update.keys()).intersection(set(NoteFactory._FORBIDDEN_UPDATE_ATTRIBUTES))
#     if any(forbidden):
#         raise ValueError("Attempt to update one or more protected note value(s): %s" % forbidden)

#     note_record = self.model_dump(exclude=NoteFactory._FORBIDDEN_COPY_ATTRIBUTES) | update
#     search_record = {key: note_record[key] for key in NoteFactory._POS_P_O_S_D_R}
#     if search_record["stroke"] in NoteFactory._ANY_DURATION_STROKES:
#         update |= {"duration": search_record["duration"]}
#         search_record["duration"] = 1
#     if search_record["stroke"] in NoteFactory._ANY_SILENCEAFTER_STROKES:
#         update |= {"rest_after": search_record["rest_after"]}
#         search_record["rest_after"] = 1
#     update |= {"uniqueid": uuid4()}

#     valid_note = NoteFactory._POS_P_O_S_D_R_TO_NOTE.get(tuple(search_record.values()), None)
#     if not valid_note:
#         raise ValueError(
#             (
#                 "Invalid combination %s OCT%s %s "
#                 % (search_record["pitch"], search_record["octave"], search_record["stroke"])
#             )
#             + (
#                 "%s %s for %s"
#                 % ({search_record["duration"]}, {search_record["rest_after"]}, {search_record["position"]})
#             )
#         )
#     updated_args_dict = valid_note.model_dump(exclude=NoteFactory._FORBIDDEN_COPY_ATTRIBUTES) | update
#     return Note(**updated_args_dict)

# def model_copy_x(
#     self,
#     **kwargs,
# ) -> Optional["Note"]:
#     """Returns a note with the same attributes as the input note, except for the given parameters.
#        Raises an error if the combination of POS_P_O_S_D_R parameters is not valid.
#     Returns:
#         Optional[Note]: A copy of the note with updated parameters or None if invalid.
#     """
#     return self.model_copy(update=kwargs)

# def to_tone(self) -> Tone:
#     return Tone(pitch=self.pitch, octave=self.octave)
